<summary>

<header>
RepopackPy Output File
This file was generated by RepopackPy on: 2025-01-14T11:18:10.656200
</header>

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository structure
3. Repository files, each consisting of:
    - File path as an attribute
    - Full contents of the file
</file_format>

<usage_guidelines>
1. This file should be treated as read-only. Any changes should be made to the
    original repository files, not this packed version.
2. When processing this file, use the file path attributes to distinguish
    between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
    the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and RepopackPy's
  configuration.
- Binary files are not included in this packed representation.
</notes>

<additional_info>
For more information about RepopackPy, visit: https://github.com/abinthomasonline/repopack-py
</additional_info>

</summary>

<repository_structure>
__init__.py
analysis\__init__.py
analysis\indicators.py
analysis\patterns.py
analysis\plot_charts.py
analysis\plot_charts_html.py
analysis\technical.py
bot\__init__.py
bot\handlers\__init__.py
bot\handlers\analysis_handlers.py
bot\handlers\callback_handler.py
bot\handlers\education_handlers.py
bot\handlers\error_handlers.py
bot\handlers\message_handler.py
bot\handlers\settings_handlers.py
bot\keyboards\__init__.py
bot\keyboards\reply_keyboards.py
bot\middlewares\__init__.py
bot\middlewares\language_middleware.py
bot\middlewares\user_middleware.py
data\__init__.py
data\cc_news.py
data\cc_test.py
data\crypto_data.py
data\market_data.py
data\processor.py
data\reddit_news.py
data\test.py
data\x_news.py
education\__init__.py
education\content.py
education\resources.py
languages\__init__.py
languages\ar\messages.json
languages\en\messages.json
llm\agent.py
services\__init__.py
services\cache_manager.py
services\coingecko_api.py
services\database.py
services\database_manager.py
services\gpt.py
services\models.py
services\pdf_generator.py
utils\__init__.py
utils\config.py
utils\constants.py
utils\decorators.py
utils\formatters.py
utils\helpers.py
utils\news_formatters.py
</repository_structure>

<repository_files>

<file path="analysis\plot_charts.py">
import mplfinance as mpf
import numpy as np
import pandas as pd
from matplotlib.backends.backend_pdf import PdfPages
import matplotlib.pyplot as plt
import matplotlib.font_manager as fm
import emoji
import re

# Font Configuration for UTF-8 and Emoji Support
plt.rcParams['font.family'] = 'DejaVu Sans'  # Ensures emojis and UTF-8 text are supported

def validate_dataframe(df):
    """Ensure the DataFrame is valid for mplfinance."""
    required_columns = {'open', 'high', 'low', 'close', 'volume'}
    if not all(col in df.columns for col in required_columns):
        raise ValueError(f"DataFrame must contain columns: {required_columns}")
    if df.empty:
        raise ValueError("DataFrame is empty. Ensure data is properly fetched.")
    if not isinstance(df.index, pd.DatetimeIndex):
        raise ValueError("DataFrame index must be a DateTimeIndex.")

def create_plot_style(grid=True, volume=True, color_up='green', color_down='red', bgcolor='white'):
    """Create a custom style for mplfinance plots."""
    return mpf.make_mpf_style(
        base_mpf_style='charles',
        gridstyle='-' if grid else '',
        marketcolors=mpf.make_marketcolors(
            up=color_up,
            down=color_down,
            edge='inherit',
            wick='inherit',
            volume='in',
            ohlc='inherit',
            alpha=0.8
        ),
        facecolor=bgcolor
    )

import re
import emoji

def clean_intro_text(intro_text):
    """
    Clean intro text by removing unrecognized characters and non-printable characters.
    
    Args:
        intro_text (str): Original input text
    
    Returns:
        str: Cleaned text with only recognized characters
    """
    if not intro_text:
        return ""
    
    # Convert to string and handle potential non-string inputs
    intro_text = str(intro_text)
    
    # Remove any characters that are not:
    # - Alphanumeric (ASCII and Unicode)
    # - Basic punctuation
    # - Whitespace
    # - Emojis
    def is_valid_char(char):
        return (
            char.isalnum() or  # Alphanumeric characters
            char.isspace() or  # Whitespace
            char in '.,;:!?()[]{}"-' or  # Basic punctuation
            '\U0001F600' <= char <= '\U0001F64F' or  # Emoticons
            '\U0001F300' <= char <= '\U0001F5FF' or  # Misc Symbols and Pictographs
            '\U0001F680' <= char <= '\U0001F6FF' or  # Transport and Map Symbols
            '\U0001F1E0' <= char <= '\U0001F1FF'     # Flags
        )
    
    # Filter out invalid characters
    cleaned_text = ''.join(char for char in intro_text if is_valid_char(char))
    
    # Process emojis
    cleaned_text = emoji.emojize(cleaned_text, language='alias')
    
    return cleaned_text

def create_intro_page(intro_text, pdf, max_lines_per_page=21, font_size=14):
    """
    Dynamically create intro pages with UTF-8 and emoji support, 
    splitting text across multiple pages if needed.
    
    Args:
        intro_text (str): Text to display
        pdf (PdfPages): PDF file to save pages to
        max_lines_per_page (int): Maximum number of lines per page
        font_size (float): Font size for text
    """
    # Clean the text first
    cleaned_text = clean_intro_text(intro_text)
    
    # Process emojis in the text
    text_lines = [emoji.emojize(line, language='alias') for line in cleaned_text.split("\n")]
    
    # Split text into pages if it exceeds max_lines_per_page
    for page_start in range(0, len(text_lines), max_lines_per_page):
        page_lines = text_lines[page_start:page_start+max_lines_per_page]
        
        # Calculate figure height dynamically
        base_height = 9  # Standard height
        
        # Create the figure
        fig, ax = plt.subplots(figsize=(8.5, base_height), facecolor='white')
        ax.axis('off')  # Hide axes
        
        # Position and render the text
        start_y = 0.95  # Start closer to the top of the page
        line_spacing = 0.04  # Reduced line spacing for tighter layout
        
        for i, line in enumerate(page_lines):
            y_pos = start_y - (i * line_spacing)
            ax.text(0.05, y_pos, line, fontsize=font_size, ha='left', va='center', wrap=True, color='black')
        
        # Add page number if multiple pages
        if len(text_lines) > max_lines_per_page:
            ax.text(0.95, 0.05, f'Page {page_start//max_lines_per_page + 1}', 
                    fontsize=10, ha='right', va='bottom', color='gray')
        
        # Save the page to PDF
        pdf.savefig(fig, bbox_inches='tight')        
        plt.close(fig)

def save_charts_to_pdf(filename, df, ma_data=None, macd_data=None, rsi_data=None, support_levels=None, resistance_levels=None, style=None, charts_to_include=None, labels=None, intro_text=None, max_lines_per_page=21):
    """
    Save selected charts into a single PDF with optional labels, legends, and an introductory text page.

    Args:
        filename (str): Output PDF filename
        df (pd.DataFrame): Financial data DataFrame
        ma_data (dict, optional): Moving average data
        macd_data (dict, optional): MACD indicator data
        rsi_data (array, optional): RSI indicator data
        support_levels (list, optional): Support price levels
        resistance_levels (list, optional): Resistance price levels
        style (mpf.style, optional): Custom plot style
        charts_to_include (list, optional): List of charts to generate
        labels (list, optional): Labels for each chart
        intro_text (str, optional): Introductory text for the first page
        max_lines_per_page (int, optional): Maximum lines per intro page
    """
    validate_dataframe(df)
    style = style or create_plot_style()
    charts_to_include = charts_to_include or ["price", "moving_averages", "macd", "rsi", "volume", "support_resistance"]
    labels = labels or [None] * len(charts_to_include)

    if len(charts_to_include) != len(labels):
        raise ValueError("The number of labels must match the number of charts to include.")

    with PdfPages(filename) as pdf:
        # Add the intro text page
        if intro_text:
            create_intro_page(intro_text, pdf, max_lines_per_page=max_lines_per_page)

        # Generate charts
        for chart, label in zip(charts_to_include, labels):
            if chart == "price":
                fig, ax = mpf.plot(df, type='candle', title='Price Chart', ylabel='Price', style=style, returnfig=True)
                pdf.savefig(fig)
                plt.close(fig)

            if chart == "moving_averages" and ma_data:
                additional_plots = [
                    mpf.make_addplot(ma_data['ma20'], color='green', width=1.5, label='20-Day MA'),
                    mpf.make_addplot(ma_data['ma50'], color='orange', width=1.5, label='50-Day MA')
                ]
                fig, ax = mpf.plot(df, type='candle', addplot=additional_plots, title='Moving Averages', ylabel='Price', style=style, returnfig=True)
                pdf.savefig(fig)
                plt.close(fig)

            if chart == "macd" and macd_data:
                additional_plots = [
                    mpf.make_addplot(macd_data['macd'], color='blue', panel=1, ylabel='MACD'),
                    mpf.make_addplot(macd_data['signal'], color='red', panel=1),
                    mpf.make_addplot(macd_data['histogram'], type='bar', color='gray', panel=1)
                ]
                fig, ax = mpf.plot(df, type='candle', addplot=additional_plots, title='MACD Indicator', style=style, returnfig=True)
                pdf.savefig(fig)
                plt.close(fig)

            if chart == "rsi" and len(rsi_data) > 0:
                additional_plots = [
                    mpf.make_addplot(rsi_data, color='purple', panel=1, ylabel='RSI'),
                    mpf.make_addplot([70] * len(df), color='red', linestyle='--', panel=1),
                    mpf.make_addplot([30] * len(df), color='green', linestyle='--', panel=1)
                ]
                fig, ax = mpf.plot(df, type='candle', addplot=additional_plots, title='RSI Indicator', style=style, returnfig=True)
                pdf.savefig(fig)
                plt.close(fig)

            if chart == "volume":
                fig, ax = mpf.plot(df, type='candle', volume=True, title='Volume', ylabel='Price', ylabel_lower='Volume', style=style, returnfig=True)
                pdf.savefig(fig)
                plt.close(fig)

            if chart == "support_resistance" and support_levels and resistance_levels:
                additional_plots = [
                    *[mpf.make_addplot([level] * len(df), color='green', linestyle='--') for level in support_levels],
                    *[mpf.make_addplot([level] * len(df), color='red', linestyle='--') for level in resistance_levels]
                ]
                fig, ax = mpf.plot(df, type='candle', addplot=additional_plots, title='Support & Resistance', ylabel='Price', style=style, returnfig=True)
                pdf.savefig(fig)
                plt.close(fig)

        print(f"Charts saved to {filename}")
</file>

<file path="analysis\plot_charts_html.py">
import datapane as dp
import pandas as pd
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import numpy as np
import emoji
import re

def validate_dataframe(df):
    """Ensure the DataFrame is valid for plotting."""
    required_columns = {'open', 'high', 'low', 'close', 'volume'}
    if not all(col in df.columns for col in required_columns):
        raise ValueError(f"DataFrame must contain columns: {required_columns}")
    if df.empty:
        raise ValueError("DataFrame is empty. Ensure data is properly fetched.")
    if not isinstance(df.index, pd.DatetimeIndex):
        raise ValueError("DataFrame index must be a DateTimeIndex.")

def create_plot_style(grid=True, volume=True, color_up='green', color_down='red', bgcolor='white'):
    """Create a custom style for plots."""
    return {
        'grid': grid,
        'volume': volume,
        'color_up': color_up,
        'color_down': color_down,
        'bgcolor': bgcolor
    }

def clean_intro_text(intro_text):
    """
    Clean intro text by removing unrecognized characters and non-printable characters.
    
    Args:
        intro_text (str): Original input text
    
    Returns:
        str: Cleaned text with only recognized characters
    """
    if not intro_text:
        return ""
    
    intro_text = str(intro_text)
    
    def is_valid_char(char):
        return (
            char.isalnum() or
            char.isspace() or
            char in '.,;:!?()[]{}"-' or
            '\U0001F600' <= char <= '\U0001F64F' or
            '\U0001F300' <= char <= '\U0001F5FF' or
            '\U0001F680' <= char <= '\U0001F6FF' or
            '\U0001F1E0' <= char <= '\U0001F1FF'
        )
    
    cleaned_text = ''.join(char for char in intro_text if is_valid_char(char))
    cleaned_text = emoji.emojize(cleaned_text, language='alias')
    
    return cleaned_text

def create_candlestick_chart(df, style):
    """Create a candlestick chart using plotly."""
    fig = go.Figure(data=[
        go.Candlestick(
            x=df.index,
            open=df['open'],
            high=df['high'],
            low=df['low'],
            close=df['close'],
            increasing_line_color=style['color_up'],
            decreasing_line_color=style['color_down']
        )
    ])
    fig.update_layout(
        title='Price Chart',
        yaxis_title='Price',
        template='plotly_white' if style['bgcolor'] == 'white' else 'plotly_dark'
    )
    return fig

def create_volume_chart(df, style):
    """Create a volume chart using plotly."""
    colors = [style['color_up'] if row['close'] >= row['open'] else style['color_down']
              for _, row in df.iterrows()]
    
    fig = go.Figure(data=[
        go.Bar(
            x=df.index,
            y=df['volume'],
            marker_color=colors
        )
    ])
    fig.update_layout(
        title='Volume',
        yaxis_title='Volume',
        template='plotly_white' if style['bgcolor'] == 'white' else 'plotly_dark'
    )
    return fig

def create_ma_chart(df, ma_data, style):
    """Create a moving averages chart using plotly."""
    fig = go.Figure()
    
    # Add candlesticks
    fig.add_trace(
        go.Candlestick(
            x=df.index,
            open=df['open'],
            high=df['high'],
            low=df['low'],
            close=df['close'],
            name='Price'
        )
    )
    
    # Add moving averages
    fig.add_trace(go.Scatter(x=df.index, y=ma_data['ma20'], name='20-Day MA', line=dict(color='green')))
    fig.add_trace(go.Scatter(x=df.index, y=ma_data['ma50'], name='50-Day MA', line=dict(color='orange')))
    
    fig.update_layout(
        title='Moving Averages',
        yaxis_title='Price',
        template='plotly_white' if style['bgcolor'] == 'white' else 'plotly_dark'
    )
    return fig

def create_macd_chart(df, macd_data, style):
    """Create a MACD chart using plotly."""
    fig = make_subplots(rows=2, cols=1, shared_xaxes=True,
                       vertical_spacing=0.1,
                       subplot_titles=('Price', 'MACD'))
    
    fig.add_trace(
        go.Candlestick(
            x=df.index,
            open=df['open'],
            high=df['high'],
            low=df['low'],
            close=df['close']
        ),
        row=1, col=1
    )
    
    fig.add_trace(
        go.Scatter(x=df.index, y=macd_data['macd'], name='MACD',
                  line=dict(color='blue')),
        row=2, col=1
    )
    
    fig.add_trace(
        go.Scatter(x=df.index, y=macd_data['signal'], name='Signal',
                  line=dict(color='red')),
        row=2, col=1
    )
    
    fig.add_trace(
        go.Bar(x=df.index, y=macd_data['histogram'], name='Histogram',
               marker_color='gray'),
        row=2, col=1
    )
    
    fig.update_layout(
        title='MACD Indicator',
        template='plotly_white' if style['bgcolor'] == 'white' else 'plotly_dark'
    )
    return fig

def create_rsi_chart(df, rsi_data, style):
    """Create an RSI chart using plotly."""
    fig = make_subplots(rows=2, cols=1, shared_xaxes=True,
                       vertical_spacing=0.1,
                       subplot_titles=('Price', 'RSI'))
    
    fig.add_trace(
        go.Candlestick(
            x=df.index,
            open=df['open'],
            high=df['high'],
            low=df['low'],
            close=df['close']
        ),
        row=1, col=1
    )
    
    fig.add_trace(
        go.Scatter(x=df.index, y=rsi_data, name='RSI',
                  line=dict(color='purple')),
        row=2, col=1
    )
    
    # Add overbought/oversold lines
    fig.add_hline(y=70, line_dash="dash", line_color="red", row=2, col=1)
    fig.add_hline(y=30, line_dash="dash", line_color="green", row=2, col=1)
    
    fig.update_layout(
        title='RSI Indicator',
        template='plotly_white' if style['bgcolor'] == 'white' else 'plotly_dark'
    )
    return fig

def create_support_resistance_chart(df, support_levels, resistance_levels, style):
    """Create a support and resistance chart using plotly."""
    fig = go.Figure()
    
    fig.add_trace(
        go.Candlestick(
            x=df.index,
            open=df['open'],
            high=df['high'],
            low=df['low'],
            close=df['close']
        )
    )
    
    # Add support levels
    for level in support_levels:
        fig.add_hline(y=level, line_dash="dash", line_color="green")
    
    # Add resistance levels
    for level in resistance_levels:
        fig.add_hline(y=level, line_dash="dash", line_color="red")
    
    fig.update_layout(
        title='Support & Resistance',
        yaxis_title='Price',
        template='plotly_white' if style['bgcolor'] == 'white' else 'plotly_dark'
    )
    return fig

import datapane as dp
import pandas as pd
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import numpy as np
import emoji
import re

# Previous helper functions remain the same...

def format_numeric_value(value):
    """
    Safely format numeric values, handling numpy arrays and other numeric types.
    
    Args:
        value: Number or numpy array to format
        
    Returns:
        str: Formatted string representation
    """
    if isinstance(value, (np.ndarray, pd.Series)):
        # If it's an array/series, take the last value
        value = value[-1] if len(value) > 0 else 0
    
    if isinstance(value, (int, np.integer)):
        return f"{value:,}"
    elif isinstance(value, (float, np.floating)):
        return f"{value:.2f}"
    else:
        return str(value)

def create_summary_cards(df):
    """Create summary statistics cards with safe value formatting."""
    try:
        latest_close = df['close'].iloc[-1]
        prev_close = df['close'].iloc[-2]
        price_change = latest_close - prev_close
        price_change_pct = (price_change / prev_close) * 100
        
        total_volume = df['volume'].iloc[-1]
        avg_volume = df['volume'].mean()
        volume_change_pct = ((total_volume - avg_volume) / avg_volume) * 100
        
        return dp.Group(
            dp.BigNumber(
                heading="Current Price",
                value=f"${format_numeric_value(latest_close)}",
                change=format_numeric_value(price_change),
                is_upward_change=price_change > 0
            ),
            dp.BigNumber(
                heading="24h Change",
                value=f"{format_numeric_value(price_change_pct)}%",
                change=format_numeric_value(abs(price_change)),
                is_upward_change=price_change > 0
            ),
            dp.BigNumber(
                heading="Volume",
                value=format_numeric_value(total_volume),
                change=f"{format_numeric_value(volume_change_pct)}%",
                is_upward_change=volume_change_pct > 0
            ),
            columns=3
        )
    except Exception as e:
        print(f"Debug: Error in create_summary_cards: {str(e)}")
        return dp.Text("Error creating summary cards")

def create_price_range_cards(df):
    """Create price range statistics cards with safe value formatting."""
    try:
        return dp.Group(
            dp.BigNumber(
                heading="All-Time High",
                value=f"${format_numeric_value(df['high'].max())}"
            ),
            dp.BigNumber(
                heading="All-Time Low",
                value=f"${format_numeric_value(df['low'].min())}"
            ),
            dp.BigNumber(
                heading="Average Price",
                value=f"${format_numeric_value(df['close'].mean())}"
            ),
            columns=3
        )
    except Exception as e:
        print(f"Debug: Error in create_price_range_cards: {str(e)}")
        return dp.Text("Error creating price range cards")

def create_technical_cards(df, ma_data=None, rsi_data=None):
    """Create technical analysis summary cards with safe value formatting."""
    try:
        cards = []
        
        if ma_data is not None:
            latest_ma20 = ma_data['ma20'].iloc[-1]
            latest_ma50 = ma_data['ma50'].iloc[-1]
            latest_price = df['close'].iloc[-1]
            
            ma20_signal = "ABOVE" if latest_price > latest_ma20 else "BELOW"
            ma50_signal = "ABOVE" if latest_price > latest_ma50 else "BELOW"
            
            cards.extend([
                dp.BigNumber(
                    heading="MA20 Signal",
                    value=ma20_signal,
                    change=format_numeric_value(latest_ma20),
                    is_upward_change=latest_price > latest_ma20
                ),
                dp.BigNumber(
                    heading="MA50 Signal",
                    value=ma50_signal,
                    change=format_numeric_value(latest_ma50),
                    is_upward_change=latest_price > latest_ma50
                )
            ])
        
        if rsi_data is not None and len(rsi_data) > 0:
            latest_rsi = rsi_data.iloc[-1] if isinstance(rsi_data, pd.Series) else rsi_data[-1]
            rsi_signal = "OVERBOUGHT" if latest_rsi > 70 else "OVERSOLD" if latest_rsi < 30 else "NEUTRAL"
            
            cards.append(
                dp.BigNumber(
                    heading="RSI Signal",
                    value=format_numeric_value(latest_rsi),
                    change=rsi_signal,
                    is_upward_change=latest_rsi > 50
                )
            )
        
        return dp.Group(*cards, columns=len(cards)) if cards else None
    except Exception as e:
        print(f"Debug: Error in create_technical_cards: {str(e)}")
        return dp.Text("Error creating technical cards")

def save_charts_to_pdf(filename, df, ma_data=None, macd_data=None, rsi_data=None, 
                      support_levels=None, resistance_levels=None, style=None, 
                      charts_to_include=None, labels=None, intro_text=None, 
                      max_lines_per_page=7):
    """
    Save selected charts into a single PDF using datapane with enhanced design and error handling.
    """
    try:
        validate_dataframe(df)
        style = style or create_plot_style()
        charts_to_include = charts_to_include or ["price", "moving_averages", "macd", "rsi", "volume", "support_resistance"]
        labels = labels or [None] * len(charts_to_include)

        if len(charts_to_include) != len(labels):
            raise ValueError("The number of labels must match the number of charts to include.")

        blocks = []
        
        # Add title and intro text
        blocks.append(dp.Text("# Financial Market Analysis Report"))
        if intro_text:
            cleaned_text = clean_intro_text(intro_text)
            blocks.append(dp.Text(cleaned_text))
        
        # Add summary section
        print("Debug: Creating summary section")
        blocks.append(dp.Text("## Market Summary"))
        summary_cards = create_summary_cards(df)
        if summary_cards:
            blocks.append(summary_cards)
        
        # Add price range section
        print("Debug: Creating price range section")
        blocks.append(dp.Text("## Price Statistics"))
        price_cards = create_price_range_cards(df)
        if price_cards:
            blocks.append(price_cards)
        
        # Add technical analysis cards
        if ma_data is not None or rsi_data is not None:
            print("Debug: Creating technical section")
            blocks.append(dp.Text("## Technical Indicators"))
            tech_cards = create_technical_cards(df, ma_data, rsi_data)
            if tech_cards:
                blocks.append(tech_cards)
        
        # Generate charts
        print("Debug: Creating charts")
        blocks.append(dp.Text("## Technical Analysis Charts"))
        for chart, label in zip(charts_to_include, labels):
            try:
                if label:
                    blocks.append(dp.Text(f"### {label}"))
                
                if chart == "price":
                    fig = create_candlestick_chart(df, style)
                    blocks.append(dp.Plot(fig))
                elif chart == "moving_averages" and ma_data:
                    fig = create_ma_chart(df, ma_data, style)
                    blocks.append(dp.Plot(fig))
                elif chart == "macd" and macd_data:
                    fig = create_macd_chart(df, macd_data, style)
                    blocks.append(dp.Plot(fig))
                elif chart == "rsi" and len(rsi_data) > 0:
                    fig = create_rsi_chart(df, rsi_data, style)
                    blocks.append(dp.Plot(fig))
                elif chart == "volume":
                    fig = create_volume_chart(df, style)
                    blocks.append(dp.Plot(fig))
                elif chart == "support_resistance" and support_levels and resistance_levels:
                    fig = create_support_resistance_chart(df, support_levels, resistance_levels, style)
                    blocks.append(dp.Plot(fig))
            except Exception as e:
                print(f"Debug: Error creating chart {chart}: {str(e)}")
                blocks.append(dp.Text(f"Error creating {chart} chart"))
        
        # Add data table
        print("Debug: Adding data table")
        blocks.append(dp.Text("## Historical Data"))
        blocks.append(dp.DataTable(df))
        
        # Create and save report
        report = dp.Report(*blocks)
        report.save(filename)
        
        print(f"Enhanced report saved to {filename}")
        
    except Exception as e:
        print(f"Debug: Error in save_charts_to_pdf: {str(e)}")
        # Create a minimal error report
        error_report = dp.Report(
            dp.Text("# Error in Report Generation"),
            dp.Text(f"An error occurred while generating the report: {str(e)}")
        )
        error_report.save(filename)
</file>

<file path="analysis\technical.py">
import talib
import numpy as np
import pandas as pd
from typing import Dict, List, Optional, Tuple
from ..data.processor import DataProcessor

class TechnicalAnalyzer:
    def __init__(self):
        self.data_processor = DataProcessor()

    def analyze_coin(self, coin_id: str, vs_currency: str = 'usd', days: int = 30) -> Dict:
        """Perform enhanced technical analysis"""
        df = self.data_processor.get_ohlcv_data(coin_id, vs_currency, days)
        if df is None:
            return {"error": "Failed to fetch data"}

        analysis = {
            "basic_info": self._get_basic_info(df),
            "trend_indicators": self._analyze_trend(df),
            "momentum_indicators": self._analyze_momentum(df),
            "volume_indicators": self._analyze_volume(df),
            "volatility_indicators": self._analyze_volatility(df),
            "support_resistance": self._find_support_resistance(df),
            "patterns": self._identify_patterns(df),
            "summary": {}
        }

        analysis["summary"] = self._generate_enhanced_summary(analysis)
        return analysis
    
    def _identify_patterns(self, df: pd.DataFrame) -> Dict:
        """Identify common candlestick patterns"""
        open = df['open'].values
        high = df['high'].values
        low = df['low'].values
        close = df['close'].values
        
        patterns = {}
        
        # Bullish patterns
        patterns['hammer'] = talib.CDLHAMMER(open, high, low, close)[-1]
        patterns['morning_star'] = talib.CDLMORNINGSTAR(open, high, low, close)[-1]
        patterns['bullish_engulfing'] = talib.CDLENGULFING(open, high, low, close)[-1]
        
        # Bearish patterns
        patterns['shooting_star'] = talib.CDLSHOOTINGSTAR(open, high, low, close)[-1]
        patterns['evening_star'] = talib.CDLEVENINGSTAR(open, high, low, close)[-1]
        patterns['hanging_man'] = talib.CDLHANGINGMAN(open, high, low, close)[-1]
        
        return {
            "patterns": {k: bool(v) for k, v in patterns.items() if v != 0}
        }
    
    def _find_support_resistance(self, df: pd.DataFrame, window: int = 20) -> Dict:
        """Find potential support and resistance levels"""
        highs = df['high'].rolling(window=window, center=True).max()
        lows = df['low'].rolling(window=window, center=True).min()
        
        current_price = df['close'].iloc[-1]
        
        # Find nearest levels
        resistance_levels = sorted([x for x in highs.unique() if x > current_price][:3])
        support_levels = sorted([x for x in lows.unique() if x < current_price][-3:])
        
        return {
            "support_levels": support_levels,
            "resistance_levels": resistance_levels
        }
    
    def _get_basic_info(self, df: pd.DataFrame) -> Dict:
        """Calculate basic price information"""
        current_price = df['close'].iloc[-1]
        price_change = ((current_price - df['close'].iloc[-2]) / df['close'].iloc[-2]) * 100
        
        return {
            "current_price": current_price,
            "price_change_24h": price_change,
            "high_24h": df['high'].iloc[-1],
            "low_24h": df['low'].iloc[-1],
            "volume_24h": df['volume'].iloc[-1]
        }

    def _analyze_momentum(self, df: pd.DataFrame) -> Dict:
        """Enhanced momentum analysis"""
        close = df['close'].values
        high = df['high'].values
        low = df['low'].values
        volume = df['volume'].values

        try:
            # RSI
            rsi = talib.RSI(close, timeperiod=14)
            
            # Stochastic
            slowk, slowd = talib.STOCH(high, low, close, 
                                     fastk_period=14, 
                                     slowk_period=3, 
                                     slowd_period=3)
            
            # Williams %R
            willr = talib.WILLR(high, low, close, timeperiod=14)
            
            # Money Flow Index
            mfi = talib.MFI(high, low, close, volume, timeperiod=14)
            
            # Commodity Channel Index
            cci = talib.CCI(high, low, close, timeperiod=20)
            
            # Rate of Change
            roc = talib.ROC(close, timeperiod=10)

            return {
                "rsi": {
                    "value": rsi[-1],
                    "signal": self._interpret_rsi(rsi[-1]),
                    "previous": rsi[-2],
                    "all":rsi
                },
                "stochastic": {
                    "k": slowk[-1],
                    "d": slowd[-1],
                    "signal": self._interpret_stochastic(slowk[-1], slowd[-1])
                },
                "williams_r": {
                    "value": willr[-1],
                    "signal": self._interpret_williams_r(willr[-1])
                },
                "mfi": {
                    "value": mfi[-1],
                    "signal": self._interpret_mfi(mfi[-1])
                },
                "cci": {
                    "value": cci[-1],
                    "signal": self._interpret_cci(cci[-1])
                },
                "roc": {
                    "value": roc[-1],
                    "signal": self._interpret_roc(roc[-1])
                }
            }
        except Exception as e:
            return {"error": f"Momentum analysis failed: {str(e)}"}

    def _interpret_roc(self, value: float) -> Dict:
        """Interpret Rate of Change (ROC) values"""
        if value > 5:
            return {
                "signal": "Bullish",
                "strength": min(100, value * 10),
                "condition": "Strong Momentum"
            }
        elif value < -5:
            return {
                "signal": "Bearish",
                "strength": min(100, abs(value * 10)),
                "condition": "Strong Negative Momentum"
            }
        return {
            "signal": "Neutral",
            "strength": 0,
            "condition": "Weak Momentum"
        }

    def _analyze_trend(self, df: pd.DataFrame) -> Dict:
        """Enhanced trend analysis"""
        try:
            close = df['close'].values
            high = df['high'].values
            low = df['low'].values

            # Adjust minimum data requirement
            min_period = 50  # Changed from 200 to allow shorter timeframes
            if len(close) < min_period:
                ma_period = len(close) - 1
                if ma_period < 10:  # Absolute minimum requirement
                    return {"error": "Not enough data for trend analysis"}
            else:
                ma_period = min_period

            # Moving Averages
            ma20 = talib.SMA(close, timeperiod=min(20, ma_period))
            ma50 = talib.SMA(close, timeperiod=min(50, ma_period))
            ema20 = talib.EMA(close, timeperiod=min(20, ma_period))
            
            # MACD (requires at least 33 periods)
            if len(close) >= 33:
                macd, macd_signal, macd_hist = talib.MACD(close)
            else:
                macd = macd_signal = macd_hist = np.array([0])
            
            # ADX (requires 14 periods)
            if len(close) >= 14:
                adx = talib.ADX(high, low, close, timeperiod=14)
            else:
                adx = np.array([0])
            
            # Parabolic SAR
            sar = talib.SAR(high, low)

            # Get last valid index
            last_valid_index = -1
            while last_valid_index >= -len(close) and (
                np.isnan(ma20[last_valid_index]) or 
                np.isnan(ma50[last_valid_index])
            ):
                last_valid_index -= 1

            if last_valid_index < -len(close):
                return {"error": "Invalid data in trend analysis"}

            return {
                "moving_averages": {
                    "ma20":ma20,
                    "ma50":ma50,
                    "ema20":ema20,
                    "signal": self._interpret_mas(
                        close[last_valid_index], 
                        ma20[last_valid_index], 
                        ma50[last_valid_index], 
                        ema20[last_valid_index]
                    )
                },
                "macd": {
                    "macd": macd,
                    "signal": macd_signal,
                    "histogram":macd_hist,
                    "interpretation": self._interpret_macd(
                        float(macd[last_valid_index]),
                        float(macd_signal[last_valid_index]),
                        float(macd_hist[last_valid_index])
                    )
                },
                "adx": {
                    "value": float(adx[last_valid_index]),
                    "strength": self._interpret_adx(float(adx[last_valid_index]))
                }
            }

        except Exception as e:
            return {"error": f"Trend analysis failed: {str(e)}"}

    def _get_signal_from_dict(self, data: Dict, key: str = 'signal') -> str:
        """Safely extract signal string from potentially nested dictionary"""
        if isinstance(data, dict):
            signal = data.get(key, 'Neutral')
            if isinstance(signal, dict):
                return signal.get(key, 'Neutral')
            return str(signal)
        return 'Neutral'

    def _generate_enhanced_summary(self, analysis: Dict) -> Dict:
        """Generate enhanced analysis summary with cross-validation"""
        signals = {
            "Bullish": 0,
            "Bearish": 0,
            "Neutral": 0
        }
        signal_strengths = []
        
        try:
            # Trend Analysis
            trend = analysis.get("trend_indicators", {})
            if isinstance(trend, dict) and "error" not in trend:
                # MACD Analysis
                macd_data = trend.get("macd", {}).get("interpretation", {})
                macd_signal = self._get_signal_from_dict(macd_data, 'crossover')
                if macd_signal in signals:
                    signals[macd_signal] += 1
                
                # Moving Averages
                ma_signal = trend.get("moving_averages", {}).get("signal", "Neutral")
                if ma_signal in signals:
                    signals[ma_signal] += 1

            # Momentum Analysis
            momentum = analysis.get("momentum_indicators", {})
            if isinstance(momentum, dict) and "error" not in momentum:
                # RSI
                rsi_data = momentum.get("rsi", {})
                rsi_signal = self._get_signal_from_dict(rsi_data)
                if rsi_signal in signals:
                    signals[rsi_signal] += 1
                    if isinstance(rsi_data, dict):
                        strength = rsi_data.get('strength', 0)
                        if isinstance(strength, (int, float)):
                            signal_strengths.append(strength)

                # Stochastic
                stoch_data = momentum.get("stochastic", {})
                stoch_signal = self._get_signal_from_dict(stoch_data)
                if stoch_signal in signals:
                    signals[stoch_signal] += 1
                    if isinstance(stoch_data, dict):
                        strength = stoch_data.get('strength', 0)
                        if isinstance(strength, (int, float)):
                            signal_strengths.append(strength)

            # Volume Analysis
            volume = analysis.get("volume_indicators", {})
            if isinstance(volume, dict):
                # OBV
                obv_signal = volume.get("obv", {}).get("signal", "Neutral")
                if obv_signal in signals:
                    signals[obv_signal] += 1

                # VWAP
                vwap_signal = volume.get("vwap", {}).get("signal", "Neutral")
                if vwap_signal in signals:
                    signals[vwap_signal] += 1

            # Calculate Overall Sentiment
            total_signals = sum(signals.values())
            if total_signals > 0:
                bullish_percentage = (signals["Bullish"] / total_signals) * 100
                bearish_percentage = (signals["Bearish"] / total_signals) * 100
                
                if bullish_percentage > 60:
                    overall_sentiment = "Bullish"
                elif bearish_percentage > 60:
                    overall_sentiment = "Bearish"
                else:
                    overall_sentiment = "Neutral"
                    
                signal_strength = np.mean(signal_strengths) if signal_strengths else 50
                confidence = min(100, (max(bullish_percentage, bearish_percentage) + signal_strength) / 2)
            else:
                overall_sentiment = "Neutral"
                confidence = 0

            # Generate key signals
            key_signals = []
            
            # Add significant signals
            if signals["Bullish"] > signals["Bearish"]:
                key_signals.append(("Bullish", f"Majority of indicators ({signals['Bullish']}/{total_signals}) showing bullish signals"))
            elif signals["Bearish"] > signals["Bullish"]:
                key_signals.append(("Bearish", f"Majority of indicators ({signals['Bearish']}/{total_signals}) showing bearish signals"))
            
            # Add volume signal if significant
            if volume.get("obv", {}).get("signal") != "Neutral":
                key_signals.append((
                    volume["obv"]["signal"],
                    f"Volume analysis shows {volume['obv']['signal'].lower()} trend"
                ))

            # Add momentum signal if significant
            if momentum.get("rsi", {}).get("value", 50) > 70:
                key_signals.append(("Bearish", "RSI indicates overbought conditions"))
            elif momentum.get("rsi", {}).get("value", 50) < 30:
                key_signals.append(("Bullish", "RSI indicates oversold conditions"))

            if not key_signals:
                key_signals.append(("Neutral", "No strong signals detected"))

            return {
                "overall_sentiment": overall_sentiment,
                "confidence": confidence,
                "signal_distribution": signals,
                "key_signals": key_signals,
                "risk_level": self._calculate_risk_level(analysis)
            }

        except Exception as e:
            print(f"Error in _generate_enhanced_summary: {str(e)}")
            return {
                "overall_sentiment": "Neutral",
                "confidence": 0,
                "signal_distribution": {"Bullish": 0, "Bearish": 0, "Neutral": 1},
                "key_signals": [("Neutral", "Analysis inconclusive")],
                "risk_level": {"level": 50, "category": "Medium", "factors": 0}
            }

    

    def _interpret_mas(self, close: float, ma20, ma50, ma200) -> str:
        """Interpret Moving Averages"""
        if close > ma20 and ma20 > ma50 and ma50 > ma200:
            return "Bullish"
        elif close < ma20 and ma20 < ma50 and ma50 < ma200:
            return "Bearish"
        elif close > ma200:
            return "Moderately Bullish"
        elif close < ma200:
            return "Moderately Bearish"
        else :
            return "Neutral"

    def _analyze_volume(self, df: pd.DataFrame) -> Dict:
        """Enhanced volume analysis"""
        close = df['close'].values
        volume = df['volume'].values
        high = df['high'].values
        low = df['low'].values

        try:
            # On Balance Volume
            obv = talib.OBV(close, volume)
            
            # Money Flow Index (already calculated in momentum)
            mfi = talib.MFI(high, low, close, volume, timeperiod=14)
            
            # Volume SMA
            vol_sma = talib.SMA(volume, timeperiod=20)
            
            # Calculate VWAP
            vwap = self._calculate_vwap(df)
            
            # Accumulation/Distribution Line
            ad = talib.AD(high, low, close, volume)
            
            # Chaikin Money Flow
            cmf = talib.ADOSC(high, low, close, volume, fastperiod=3, slowperiod=10)

            return {
                "obv": {
                    "value": obv[-1],
                    "change": ((obv[-1] - obv[-2]) / obv[-2] * 100) if obv[-2] != 0 else 0,
                    "signal": self._interpret_obv(obv[-3:])
                },
                "volume_sma": {
                    "current_volume": volume[-1],
                    "sma": vol_sma[-1],
                    "ratio": volume[-1] / vol_sma[-1] if vol_sma[-1] != 0 else 0
                },
                "vwap": {
                    "value": vwap[-1] if not pd.isna(vwap[-1]) else None,
                    "signal": self._interpret_vwap(close[-1], vwap[-1]) if not pd.isna(vwap[-1]) else None
                },
                "accumulation_distribution": {
                    "value": ad[-1],
                    "signal": self._interpret_ad(ad[-3:], close[-3:])
                },
                "chaikin_money_flow": {
                    "value": cmf[-1],
                    "signal": self._interpret_cmf(cmf[-1])
                }
            }
        except Exception as e:
            return {"error": f"Volume analysis failed: {str(e)}"}

    def _analyze_volatility(self, df: pd.DataFrame) -> Dict:
        """Enhanced volatility analysis"""
        close = df['close'].values
        high = df['high'].values
        low = df['low'].values

        try:
            # Bollinger Bands
            upper, middle, lower = talib.BBANDS(close, timeperiod=20)
            
            # ATR
            atr = talib.ATR(high, low, close, timeperiod=14)
            
            # Standard Deviation
            stddev = talib.STDDEV(close, timeperiod=20)
            
            # Calculate Historical Volatility
            returns = np.log(close[1:] / close[:-1])
            hist_vol = np.std(returns) * np.sqrt(252) * 100  # Annualized

            return {
                "bollinger_bands": {
                    "upper": upper[-1],
                    "middle": middle[-1],
                    "lower": lower[-1],
                    "bandwidth": (upper[-1] - lower[-1]) / middle[-1] * 100,
                    "signal": self._interpret_bbands(close[-1], upper[-1], lower[-1])
                },
                "atr": {
                    "value": atr[-1],
                    "percentage": (atr[-1] / close[-1]) * 100,
                    "interpretation": self._interpret_atr(atr[-1], close[-1])
                },
                "historical_volatility": {
                    "value": hist_vol,
                    "interpretation": self._interpret_volatility(hist_vol)
                },
                "standard_deviation": {
                    "value": stddev[-1],
                    "relative": (stddev[-1] / close[-1]) * 100
                }
            }
        except Exception as e:
            return {"error": f"Volatility analysis failed: {str(e)}"}

    # Helper methods for calculations and interpretations...
    def _calculate_vwap(self, df: pd.DataFrame) -> np.ndarray:
        """Calculate VWAP"""
        df['typical_price'] = (df['high'] + df['low'] + df['close']) / 3
        df['vwap'] = (df['typical_price'] * df['volume']).cumsum() / df['volume'].cumsum()
        return df['vwap'].values

    def _calculate_ichimoku_line(self, high: np.ndarray, low: np.ndarray, period: int) -> np.ndarray:
        """Calculate Ichimoku lines"""
        period_high = pd.Series(high).rolling(window=period).max()
        period_low = pd.Series(low).rolling(window=period).min()
        return (period_high + period_low) / 2

    # Interpretation methods will be implemented in the next part...
    # ... Previous code remains the same until interpretation methods ...

    def _interpret_rsi(self, value: float) -> Dict:
        """Interpret RSI values"""
        if value > 70:
            return {
                "condition": "Overbought",
                "signal": "Bearish",
                "strength": min(100, (value - 70) * 3.33)  # Scale 0-100
            }
        elif value < 30:
            return {
                "condition": "Oversold",
                "signal": "Bullish",
                "strength": min(100, (30 - value) * 3.33)
            }
        return {
            "condition": "Neutral",
            "signal": "Neutral",
            "strength": 0
        }

    def _interpret_stochastic(self, k: float, d: float) -> Dict:
        """Interpret Stochastic oscillator"""
        signal = "Neutral"
        strength = 0
        
        if k > 80 and d > 80:
            signal = "Bearish"
            strength = min(100, (k - 80) * 5)
        elif k < 20 and d < 20:
            signal = "Bullish"
            strength = min(100, (20 - k) * 5)
        elif k > d:
            signal = "Bullish"
            strength = min(100, (k - d) * 2)
        elif d > k:
            signal = "Bearish"
            strength = min(100, (d - k) * 2)
            
        return {
            "signal": signal,
            "strength": strength,
            "crossover": "Bullish" if k > d else "Bearish"
        }

    def _interpret_williams_r(self, value: float) -> Dict:
        """Interpret Williams %R"""
        if value > -20:
            return {
                "condition": "Overbought",
                "signal": "Bearish",
                "strength": min(100, (-value + 20) * 5)
            }
        elif value < -80:
            return {
                "condition": "Oversold",
                "signal": "Bullish",
                "strength": min(100, (-80 - value) * 5)
            }
        return {
            "condition": "Neutral",
            "signal": "Neutral",
            "strength": 0
        }

    def _interpret_macd(self, macd: float, signal: float, hist: float) -> Dict:
        """Interpret MACD signals"""
        crossover = "None"
        if (macd > signal and hist > 0):
            crossover = "Bullish"
        elif (macd < signal and hist < 0):
            crossover = "Bearish"
            
        strength = min(100, abs(hist) * 100)
            
        return {
            "crossover": crossover,
            "strength": strength,
            "histogram_direction": "Up" if hist > 0 else "Down"
        }

    def _interpret_adx(self, value: float) -> Dict:
        """Interpret ADX strength"""
        if value >= 50:
            strength = "Very Strong"
            signal_strength = 100
        elif value >= 25:
            strength = "Strong"
            signal_strength = 75
        elif value >= 20:
            strength = "Moderate"
            signal_strength = 50
        else:
            strength = "Weak"
            signal_strength = 25
            
        return {
            "trend_strength": strength,
            "signal_strength": signal_strength
        }

    def _interpret_bbands(self, price: float, upper: float, lower: float) -> Dict:
        """Interpret Bollinger Bands"""
        bandwidth = (upper - lower) / ((upper + lower) / 2) * 100
        
        if price >= upper:
            return {
                "condition": "Overbought",
                "signal": "Bearish",
                "volatility": "High" if bandwidth > 20 else "Normal",
                "strength": min(100, ((price - upper) / upper) * 100)
            }
        elif price <= lower:
            return {
                "condition": "Oversold",
                "signal": "Bullish",
                "volatility": "High" if bandwidth > 20 else "Normal",
                "strength": min(100, ((lower - price) / lower) * 100)
            }
        return {
            "condition": "Neutral",
            "signal": "Neutral",
            "volatility": "High" if bandwidth > 20 else "Normal",
            "strength": 0
        }

    def _interpret_volume(self, current_volume: float, avg_volume: float) -> Dict:
        """Interpret volume signals"""
        vol_ratio = current_volume / avg_volume if avg_volume > 0 else 1
        
        if vol_ratio >= 2:
            strength = "Very High"
            signal_strength = 100
        elif vol_ratio >= 1.5:
            strength = "High"
            signal_strength = 75
        elif vol_ratio >= 1:
            strength = "Normal"
            signal_strength = 50
        else:
            strength = "Low"
            signal_strength = 25
            
        return {
            "volume_strength": strength,
            "signal_strength": signal_strength,
            "ratio": vol_ratio
        }

    def _interpret_ichimoku(self, price: float, tenkan: float, kijun: float) -> Dict:
        """Interpret Ichimoku signals"""
        if price > tenkan and tenkan > kijun:
            return {
                "signal": "Bullish",
                "strength": min(100, ((price - kijun) / kijun) * 100),
                "condition": "Strong Uptrend"
            }
        elif price < tenkan and tenkan < kijun:
            return {
                "signal": "Bearish",
                "strength": min(100, ((kijun - price) / kijun) * 100),
                "condition": "Strong Downtrend"
            }
        return {
            "signal": "Neutral",
            "strength": 0,
            "condition": "Ranging"
        }

    

    def _get_key_signals(self, analysis: Dict) -> List[Tuple[str, str]]:
        """Extract key signals from analysis"""
        signals = []
        
        try:
            # Trend Signals
            trend_data = analysis.get("trend_indicators", {})
            if isinstance(trend_data, dict) and "macd" in trend_data:
                macd_data = trend_data["macd"]
                if macd_data.get("interpretation", {}).get("crossover") != "None":
                    signals.append((
                        macd_data["interpretation"]["crossover"],
                        f"MACD showing {macd_data['interpretation']['crossover'].lower()} crossover"
                    ))

            # Momentum Signals
            momentum_data = analysis.get("momentum_indicators", {})
            if isinstance(momentum_data, dict) and "rsi" in momentum_data:
                rsi_data = momentum_data["rsi"]
                if rsi_data.get("signal") != "Neutral":
                    signals.append((
                        rsi_data["signal"],
                        f"RSI indicates {rsi_data.get('condition', '').lower()} conditions"
                    ))

            # Volume Signals (since they're working)
            volume_data = analysis.get("volume_indicators", {})
            if isinstance(volume_data, dict):
                if volume_data.get("obv", {}).get("signal") != "Neutral":
                    signals.append((
                        volume_data["obv"]["signal"],
                        f"Volume analysis shows {volume_data['obv']['signal'].lower()} trend"
                    ))
            
                if volume_data.get("vwap", {}).get("signal") != "Neutral":
                    signals.append((
                        volume_data["vwap"]["signal"],
                        f"VWAP indicates {volume_data['vwap']['signal'].lower()} trend"
                    ))

            # Volatility Signals
            volatility_data = analysis.get("volatility_indicators", {})
            if isinstance(volatility_data, dict) and "bollinger_bands" in volatility_data:
                bb_data = volatility_data["bollinger_bands"]
                if bb_data.get("signal") != "Neutral":
                    signals.append((
                        bb_data["signal"],
                        f"Bollinger Bands indicate {bb_data.get('condition', '').lower()} conditions"
                    ))

        except Exception as e:
            print(f"Error in _get_key_signals: {str(e)}")
            # Add a default signal if there's an error
            signals.append(("Neutral", "Unable to generate detailed signals"))

        return signals

    def _calculate_risk_level(self, analysis: Dict) -> Dict:
        """Calculate overall risk level"""
        risk_factors = []
        
        # Volatility risk
        volatility = analysis["volatility_indicators"]
        if "error" not in volatility:
            bb_width = volatility["bollinger_bands"]["bandwidth"]
            risk_factors.append(min(100, bb_width))
            
        # Trend strength risk (inverse of ADX)
        trend = analysis["trend_indicators"]
        if "error" not in trend:
            adx_value = trend["adx"]["value"]
            risk_factors.append(100 - min(100, adx_value))
            
        # Volume risk
        volume = analysis["volume_indicators"]
        if "error" not in volume:
            vol_ratio = volume["volume_sma"]["ratio"]
            risk_factors.append(min(100, vol_ratio * 50))
            
        # Calculate overall risk
        risk_level = np.mean(risk_factors) if risk_factors else 50
        
        return {
            "level": risk_level,
            "category": "High" if risk_level > 70 else "Medium" if risk_level > 30 else "Low",
            "factors": len(risk_factors)
        }
        
    def _interpret_mas(self, current_price: float, ma20: float, ma50: float, ma200: float) -> str:
        """Interpret Moving Averages"""
        if current_price > ma20 and ma20 > ma50 and ma50 > ma200:
            return "Bullish"
        elif current_price < ma20 and ma20 < ma50 and ma50 < ma200:
            return "Bearish"
        elif current_price > ma50 and ma50 > ma200:
            return "Moderately Bullish"
        elif current_price < ma50 and ma50 < ma200:
            return "Moderately Bearish"
        return "Neutral"

    def _interpret_mfi(self, value: float) -> Dict:
        """Interpret Money Flow Index"""
        if value > 80:
            return {
                "condition": "Overbought",
                "signal": "Bearish",
                "strength": min(100, (value - 80) * 5)
            }
        elif value < 20:
            return {
                "condition": "Oversold",
                "signal": "Bullish",
                "strength": min(100, (20 - value) * 5)
            }
        return {
            "condition": "Neutral",
            "signal": "Neutral",
            "strength": 0
        }

    def _interpret_obv(self, obv_values: np.ndarray) -> str:
        """Interpret On Balance Volume"""
        if len(obv_values) < 2:
            return "Neutral"
        
        obv_change = obv_values[-1] - obv_values[0]
        
        if obv_change > 0:
            return "Bullish"
        elif obv_change < 0:
            return "Bearish"
        return "Neutral"

    def _interpret_ad(self, ad_values: np.ndarray, price_values: np.ndarray) -> str:
        """Interpret Accumulation/Distribution"""
        if len(ad_values) < 2 or len(price_values) < 2:
            return "Neutral"
            
        ad_change = ad_values[-1] - ad_values[0]
        price_change = price_values[-1] - price_values[0]
        
        if ad_change > 0 and price_change < 0:
            return "Bullish"  # Accumulation
        elif ad_change < 0 and price_change > 0:
            return "Bearish"  # Distribution
        return "Neutral"

    def _interpret_cmf(self, value: float) -> str:
        """Interpret Chaikin Money Flow"""
        if value > 0.25:
            return "Bullish"
        elif value < -0.25:
            return "Bearish"
        return "Neutral"

    def _interpret_atr(self, atr_value: float, current_price: float) -> Dict:
        """Interpret Average True Range"""
        atr_percentage = (atr_value / current_price) * 100
        
        if atr_percentage > 5:
            volatility = "Very High"
            risk = "High"
        elif atr_percentage > 3:
            volatility = "High"
            risk = "Moderate to High"
        elif atr_percentage > 1:
            volatility = "Moderate"
            risk = "Moderate"
        else:
            volatility = "Low"
            risk = "Low"
            
        return {
            "volatility": volatility,
            "risk": risk,
            "atr_percentage": atr_percentage
        }

    def _interpret_vwap(self, current_price: float, vwap: float) -> str:
        """Interpret VWAP"""
        if current_price > vwap:
            return "Bullish"
        elif current_price < vwap:
            return "Bearish"
        return "Neutral"

    def _interpret_volatility(self, volatility: float) -> str:
        """Interpret Historical Volatility"""
        if volatility > 100:
            return "Extremely High"
        elif volatility > 50:
            return "Very High"
        elif volatility > 30:
            return "High"
        elif volatility > 20:
            return "Moderate"
        return "Low"
    
    def _interpret_cci(self, value: float) -> Dict:
        """Interpret CCI values"""
        if value > 100:
            return {
                "condition": "Overbought",
                "signal": "Bearish",
                "strength": min(100, (value - 100))
            }
        elif value < -100:
            return {
                "condition": "Oversold",
                "signal": "Bullish",
                "strength": min(100, abs(value + 100))
            }
        return {
            "condition": "Neutral",
            "signal": "Neutral",
            "strength": 0
        }
</file>

<file path="bot\handlers\analysis_handlers.py">
from src.bot import keyboards
from src.bot.keyboards import reply_keyboards
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes

from src.services.database_manager import DatabaseManager
from ...analysis.technical import TechnicalAnalyzer
from ...utils.formatters import TelegramFormatter
from ...utils.news_formatters import NewsFormatter
from ...data.processor import DataProcessor
import asyncio
from ...data.cc_news import CryptoNewsFetcher
from ...analysis.plot_charts_html import (
    create_plot_style,
    save_charts_to_pdf
)
import tempfile
import os

class AnalysisHandler:
    def __init__(self):
        self.analyzer = TechnicalAnalyzer()
        self.formatter = TelegramFormatter()
        self.data_processor = DataProcessor()
        self.news_fetcher = CryptoNewsFetcher(os.getenv("CRYPTO_NEWS_TOKEN"))
        self.news_formatter = NewsFormatter()
        self.keyboards = reply_keyboards.AnalysisKeyboards()
        self.db_manager = DatabaseManager()
        # Default timeframes
        self.timeframes = {
            '1d': 1,
            '1w': 7,
            '1m': 30,
            '3m': 90
        }

    async def cmd_news(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        self.formatter.set_language(context.user_data['language'])

        """Handler for /news command"""
        if not context.args:
            await update.message.reply_text(
                self.formatter._t('provide_symbol_news')
            )
            return

        coin_symbol = context.args[0].upper()
        
        # Show loading message
        loading_message = await update.message.reply_text(
            self.formatter.format_loading_message()
        )

        try:
            # Get news articles
            news_df, success = self.news_fetcher.get_news_by_coin(
                categories=coin_symbol,
                limit=10,
                lang="EN"
            )
            
            if not success or news_df.empty:
                await loading_message.edit_text(
                         f" {self.formatter._t('no_news_found')}: {coin_symbol}"
                )
                return

            # Get formatted message
            formatted_message = self.news_formatter.format_news(news_df, coin_symbol)
            
            # Send news summary
            await loading_message.edit_text(
                formatted_message,
                disable_web_page_preview=True  # Prevent URL previews from cluttering the message
            )

        except Exception as e:
            await loading_message.edit_text(
                self.formatter.format_error_message(str(e))
            )

    async def cmd_analyze(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handler for /analyze command"""
        if not context.args:
            await update.message.reply_text(
                f"{self.formatter._t('provide_symbol_prompt')}\n"
                f"{self.formatter._t('analyze_example')}\n"
                f"{self.formatter._t('timeframe_optional')}"
            )
            return
      
        coin_id = context.args[0].lower()       
        timeframe = context.args[1].lower() if len(context.args) > 1 else '1d'
        if timeframe not in self.timeframes:
            await update.message.reply_text(self.formatter._t('invalid_timeframe'))
            return

        # Show loading message
        loading_message = await update.message.reply_text(
            self.formatter._t('loading')
        )

        try:
            if not self.data_processor.validate_coin_id(coin_id):
                await loading_message.edit_text(
                    f" {self.formatter._t('invalid_symbol')}: {coin_id}\n"
                    f"{self.formatter._t('provide_symbol_prompt')}"
                )
                return

            # Get analysis
            days = self.timeframes[timeframe]
            analysis = self.analyzer.analyze_coin(coin_id, days=days)
            
            # Send text analysis
            formatted_message = self.formatter.format_full_analysis(analysis, coin_id)
            await loading_message.edit_text(formatted_message)

            # Generate and send charts
            # await self._send_analysis_charts(update, analysis, coin_id,formatted_message)
            await self._generate_and_send_chart( 
        update=update, 
        coin_id= coin_id, 
        chart_type= 'full', 
        days=days,
        loading_message = update.message,
        intro_text=formatted_message
    )
            # log the activities in the database
            self.db_manager.log_user_activity({
                'user_id':update.message.from_user.id,
                'coin_id':coin_id,
                'activity_type':'full',
                'timestamp':days}) 
            self.db_manager.log_user_search({
                'user_id':update.message.from_user.id,
                'coin_id':coin_id,}) 
            
        except Exception as e:
            print(str(e))
            # await loading_message.edit_text(
            #     self.formatter.format_error_message(str(e))
            # )

    async def cmd_quick(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        self.formatter.set_language(context.user_data['language'])

        """Handler for /quick command"""
        if not context.args:
            await update.message.reply_text(
                f"{self.formatter._t('provide_symbol_prompt')}\n"
                f"{self.formatter._t('quick_example')}"
            )
            return

        coin_id = context.args[0].lower()
        
        # Show loading message
        loading_message = await update.message.reply_text(
            self.formatter.format_loading_message()
        )

        try:
            # Validate coin
            if not self.data_processor.validate_coin_id(coin_id):
                await loading_message.edit_text(
                     f" {self.formatter._t('invalid_symbol')}: {coin_id}\n"
                    f"{self.formatter._t('try_different_symbol')}"
                )
                return

            # Get quick analysis
            analysis = self.analyzer.analyze_coin(coin_id=coin_id,days=1)
            formatted_message = self.formatter._format_summary(analysis['summary'])
            
            # Send text analysis
            await loading_message.edit_text(formatted_message)

            # Send basic price chart
            # await self._send_price_chart(update, analysis, coin_id,formatted_message)
            await self._generate_and_send_chart(
        update= update, 
        coin_id=coin_id, 
        chart_type = 'price',
        days=1, 
        loading_message=update.message,
        intro_text=formatted_message
    )
            # log the activities in the database

            self.db_manager.log_user_activity({
                'user_id':update.message.from_user.id,
                'coin_id':coin_id,
                'activity_type':'price',
                'timestamp':1})
            self.db_manager.log_user_search({
                'user_id':update.message.from_user.id,
                'coin_id':coin_id,})
        except Exception as e:
            await loading_message.edit_text(
                self.formatter.format_error_message(str(e))
            )

    async def cmd_chart(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        self.formatter.set_language(context.user_data['language'])
        """Handler for /chart command"""
        if len(context.args) < 2:
            await update.message.reply_text(
           f"{self.formatter._t('provide_symbol_and_chart')}\n"
           f"{self.formatter._t('chart_example')}\n"
           f"{self.formatter._t('available_chart_types')}"
            )
            return

        coin_id = context.args[0].lower()
        chart_type = context.args[1].lower()
        timeframe = context.args[2].lower() if len(context.args) > 2 else '1d'

        if timeframe not in self.timeframes:
            await update.message.reply_text(
                self.formatter._t('invalid_timeframe')           
                )
            return

        # Show loading message
        loading_message = await update.message.reply_text(
            self.formatter.format_loading_message()
        )

        try:
            days = self.timeframes[timeframe]
            await self._generate_and_send_chart(
                update, 
                coin_id, 
                chart_type, 
                days,
                loading_message
            )
            # log the activities in the database
            self.db_manager.log_user_activity({
                'user_id':update.message.from_user.id,
                'coin_id':coin_id,
                'activity_type':chart_type,
                'timestamp':days})
            
            self.db_manager.log_user_search({
                'user_id':update.message.from_user.id,
                'coin_id':coin_id,})

        except Exception as e:
            await loading_message.edit_text(
                self.formatter.format_error_message(str(e))
            )


    async def _generate_and_send_chart(
    self, 
    update: Update, 
    coin_id: str, 
    chart_type: str, 
    days: int,
    loading_message: Update.message,
    intro_text=None
):
        """Generate and send specific chart type with progress bar."""
        try:
            # Initialize progress
            progress = 0
            progress_bar_template = self.formatter._t('generating_chart_progress')

            async def update_progress_bar(target_progress,loading_message):
                steps=3
                delay=0.1
                """
                Smoothly update the progress bar to the target percentage.
                
                Args:
                    target_progress (int): The target progress percentage (0 to 100).
                    steps (int): The number of smooth steps to reach the target.
                    delay (float): Time delay (in seconds) between steps.
                """
                nonlocal progress  # Use the outer `progress` variable
                increment = (target_progress - progress) / steps
                current_message = None  # Store the last sent message content

                for _ in range(steps):
                    progress += increment
                    filled_length = int(20 * progress / 100)  # Bar length: 20 chars
                    bar = "" * filled_length + " " * (20 - filled_length)
                    new_message = progress_bar_template.format(bar, int(progress))

                    # Only update if the message content has changed
                    if new_message != current_message:
                        current_message = new_message
                        await loading_message.edit_text(new_message)

                    await asyncio.sleep(delay)
            # Step 1: Load OHLCV data
            loading_message = await update.message.reply_text(
            self.formatter.format_loading_message()
        )
            await update_progress_bar(progress,loading_message)
            df = self.data_processor.get_ohlcv_data(coin_id=coin_id, days=days)

            await update_progress_bar(progress+ 20,loading_message)

            # Step 2: Perform analysis
            analysis = self.analyzer.analyze_coin(coin_id, days=days)
            await update_progress_bar(progress+20,loading_message)

            with tempfile.TemporaryDirectory() as temp_dir:
                chart_path = os.path.join(temp_dir, f'{chart_type}_chart.html')

                # Step 3: Generate chart based on type
                if chart_type == 'price':
                    save_charts_to_pdf(filename=chart_path, df=df, style=create_plot_style(color_up='blue', color_down='orange', bgcolor='lightgray'), charts_to_include=['price'])
                elif chart_type == 'ma':
                    ma_data = analysis['trend_indicators']['moving_averages']
                    save_charts_to_pdf(filename=chart_path, df=df, ma_data=ma_data, style=create_plot_style(color_up='blue', color_down='orange', bgcolor='lightgray'), charts_to_include=['moving_averages'])
                elif chart_type == 'macd':
                    macd_data = analysis['trend_indicators']['macd']
                    save_charts_to_pdf(filename=chart_path, df=df, macd_data=macd_data, style=create_plot_style(color_up='blue', color_down='orange', bgcolor='lightgray'), charts_to_include=['macd'])
                elif chart_type == 'rsi':
                    rsi_data = analysis['momentum_indicators']['rsi']['all']
                    save_charts_to_pdf(filename=chart_path, df=df, rsi_data=rsi_data, style=create_plot_style(color_up='blue', color_down='orange', bgcolor='lightgray'), charts_to_include=['rsi'])
                elif chart_type == 'volume':
                    save_charts_to_pdf(filename=chart_path, df=df, style=create_plot_style(color_up='blue', color_down='orange', bgcolor='lightgray'), charts_to_include=['volume'])
                elif chart_type == 'full':
                    ma_data = analysis['trend_indicators']['moving_averages']  
                    macd_data = analysis['trend_indicators']['macd']
                    rsi_data = analysis['momentum_indicators']['rsi']['all']    
                    save_charts_to_pdf(
                        filename=chart_path,
                        df=df,
                        ma_data=ma_data,
                        macd_data=macd_data,
                        rsi_data=rsi_data,
                        style=create_plot_style(color_up='blue', color_down='orange', bgcolor='lightgray'),
                        charts_to_include=['price', 'moving_averages', 'macd', 'rsi', 'volume'],
                        intro_text=intro_text
                    )
                
                else:
                    await loading_message.edit_text(self.formatter._t('invalid_chart_type'))
                    return

                await update_progress_bar(progress+40,loading_message)

                # Step 4: Send the chart
                if os.path.exists(chart_path):
                    await loading_message.delete()
                    await update.message.reply_document(
                        document=open(chart_path, 'rb'),
                        caption=f"{coin_id.upper()} {chart_type.upper()} Chart ({days}d)"
                    )
                    

            # Final progress update
            await update.message.reply_text(self.formatter._t('chart_complete'),reply_markup=self.keyboards.get_main_menu())
            return
        except Exception as e:
            await loading_message.edit_text(f"{self.formatter._t('error_generating_chart')}: {str(e)}")
</file>

<file path="bot\handlers\callback_handler.py">
# src/bot/handlers/callback_handler.py
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import ContextTypes

from src.services.database import AdminTypes, UserType
from src.services.database_manager import DatabaseManager
from ..keyboards.reply_keyboards import AnalysisKeyboards
from .analysis_handlers import AnalysisHandler
from ...utils.formatters import TelegramFormatter


class CallbackHandler:
    def __init__(self):
        self.keyboards = AnalysisKeyboards()
        self.analysis_handler = AnalysisHandler()
        self.formatter = TelegramFormatter()  # Add formatter
        self.db_manager = DatabaseManager()
        self.user_states = {'language':'en'}  # Store user states

    async def handle_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle callback queries from inline keyboards"""
        query = update.callback_query
        user_id = update.effective_user.id
        data = query.data
        
        if 'language' not in context.user_data:
            context.user_data['language'] =  self.db_manager.get_user_by_telegram_id(user_id)['language'] # Default to 'en'
        
        # Set formatter language based on context
        self.formatter.set_language(context.user_data['language'])
        
        try:
            # Handle main menu callbacks
            if data.startswith("menu_"):
                await self._handle_menu_selection(query, user_id)
            
            # Handle analysis callbacks
            elif data.startswith("analysis_"):
                await self._handle_analysis_selection(query, user_id)
            
            # Handle timeframe callbacks
            elif data.startswith("timeframe_"):
                await self._handle_timeframe_selection(query, user_id)
            
            # Handle chart callbacks
            elif data.startswith("chart_"):
                await self._handle_chart_selection(query, user_id)
            
            # Handle settings callbacks
            elif data.startswith("settings_"):
                await self._handle_settings_selection(query, user_id, context)
            
            # Handle back buttons
            elif data.startswith("back_"):
                await self._handle_back_button(query, user_id)
            
            elif data.startswith("admin_"):
                await self._handle_admin_selection(query, user_id)
            elif data.startswith("tracking_"):
                await self._handle_tracking_selection(query, user_id)
            elif data.startswith("users_"):
                await self._handle_users_action(query, user_id)
            elif data.startswith("back_"):
                await self._handle_back_button(query, user_id)
            elif data.startswith("adminsconf_"):
                await self._handle_admins_action(query, user_id)
            elif data.startswith('toggle_ban'):
                await self._handle_user_ban(query,context=context,user_id=user_id)
            elif data.startswith('change_user_subscrption'):
                await self._handle_change_user_subscrption(query,context=context,user_id=user_id)
            elif data.startswith('remove_admin'):
                await self._handle_admin_remove(query,context=context,user_id=user_id)
            elif data.startswith('add_admin'):
                await self._handle_admin_add(query,context=context,user_id=user_id)
            elif data.startswith('change_admin_'):
                await self._handle_change_admin_role(query,context=context,user_id=user_id)

                                
            elif data.startswith("help_"):
                await self._handle_help_selection(query, user_id)
                
            elif data.startswith("education_"):
                await self._handle_education_selection(query, user_id)


        except Exception as e:
            await query.answer(f"{self.formatter._t('error')}: {str(e)}")

    # Existing methods: _handle_menu_selection, _handle_analysis_selection,
    # _handle_timeframe_selection, _handle_chart_selection, _handle_settings_selection
    # _handle_back_button, _handle_help_selection.
    async def _handle_menu_selection(self, query, user_id):
      # Existing method, no changes
        """Handle main menu selections"""
        action = query.data.split("_")[1]
        
        if action == "analysis":
            await query.edit_message_text(
                self.formatter._t('select_analysis'),
                reply_markup=self.keyboards.get_analysis_menu()
            )
            
        elif action == "charts":
            await query.edit_message_text(
                self.formatter._t('select_chart_type'),
                reply_markup=self.keyboards.get_chart_types()
            )
            
        elif action == "help":
            await query.edit_message_text(
                self.formatter._t('help_menu'),
                reply_markup=self.keyboards.get_help_menu()
            )
            
        elif action == "settings":
            await query.edit_message_text(
                self.formatter._t('select_settings'),
                reply_markup=self.keyboards.get_settings_menu()
            )
        elif action == "education":
             await query.edit_message_text(
                self.formatter._t('education_menu'),
                reply_markup=self.keyboards.get_education_menu()
            )
    async def _handle_analysis_selection(self, query, user_id):
      # Existing method, no changes
        """Handle analysis type selections"""
        action = query.data.split("_")[1]
        
        if action == "quick":
            self.user_states[user_id] = {"action": "quick_analysis"}
            await query.edit_message_text(
                self.formatter._t('provide_symbol_prompt')
            )
        
        elif action == "news":
            self.user_states[user_id] = {"action": "news_analysis"}
            await query.edit_message_text(
                self.formatter._t('provide_symbol_prompt')
            )
            
        elif action == "full":
            self.user_states[user_id] = {"action": "full_analysis"}
            await query.edit_message_text(
                self.formatter._t('provide_symbol_prompt'),
                reply_markup=self.keyboards.get_timeframe_selection()
            )
            
        elif action == "custom":
            await query.edit_message_text(
                self.formatter._t('select_chart_type'),
                reply_markup=self.keyboards.get_chart_types()
            )

    async def _handle_timeframe_selection(self, query, user_id):
      # Existing method, no changes
        """Handle timeframe selections"""
        timeframe = query.data.split("_")[1]
        state = self.user_states.get(user_id, {})
        state["timeframe"] = timeframe
        self.user_states[user_id] = state
        
        timeframe_display = self.formatter._t(f'time_{timeframe}')
        await query.edit_message_text(
            f"{self.formatter._t('timeframe_set')} {timeframe_display}\n"
            f"{self.formatter._t('provide_symbol_prompt')}"
        )

    async def _handle_chart_selection(self, query, user_id):
      # Existing method, no changes
        """Handle chart type selections"""
        chart_type = query.data.split("_")[1]
        self.user_states[user_id] = {"action": "chart", "type": chart_type}
        
        chart_name = self.formatter._t(f'{chart_type}_chart')
        await query.edit_message_text(
            f"{self.formatter._t('selected_chart')} {chart_name}\n"
            f"{self.formatter._t('provide_symbol_prompt')}",
            reply_markup=self.keyboards.get_timeframe_selection()
        )

    async def _handle_settings_selection(self, query, user_id, context):
        """Handle settings selections"""
        setting = query.data.split("_")[1]
        
        if setting == "language":
            try:    
                if 'language' not in context.user_data:
                    context.user_data['language'] = 'en'

                new_lang = 'en' if context.user_data['language'] == 'ar' else 'ar'
                if self.db_manager.update_user_language(user_id=user_id,new_lang=new_lang):

                    context.user_data['language'] = new_lang

                    self.formatter.set_language(new_lang)
                    
                    await query.edit_message_text(
                        self.formatter._t('language_updated'),
                        reply_markup=self.keyboards.get_main_menu()
                    )
            except Exception as e:
                await query.edit_message_text(
                        self.formatter._t('error'),
                        reply_markup=self.keyboards.get_main_menu()
                    )
                print(e)
            
        elif setting == "timeframe":
            await query.edit_message_text(
                self.formatter._t('select_timeframe'),
                reply_markup=self.keyboards.get_timeframe_selection()
            )
        elif setting == "chart":
            await query.edit_message_text(
                self.formatter._t('select_chart_type'),
                reply_markup=self.keyboards.get_chart_types()
            )

    async def _handle_back_button(self, query, user_id):
        """Handle back button presses"""
        destination = query.data.split("_")[1]
        
        if destination == "main":
            await query.edit_message_text(
                self.formatter._t('main_menu'),
                reply_markup=self.keyboards.get_main_menu()
            )
        elif destination == "analysis":
            await query.edit_message_text(
                self.formatter._t('select_analysis'),
                reply_markup=self.keyboards.get_analysis_menu()
            )
        elif destination == "admin":
            # Back to admin main menu
            await query.edit_message_text(
                self.formatter._t('admin_menu'),
                reply_markup=self.keyboards.get_admin_menu()
            )
        elif destination == "tracking":
            # Back to user tracking menu
            await query.edit_message_text(
                self.formatter._t('select_tracking_option'),
                reply_markup=self.keyboards.get_user_tracking_menu()
            )
        elif destination == "users_managing":
            # Back to users managing menu
            await query.edit_message_text(
                self.formatter._t('select_user_management_option'),
                reply_markup=self.keyboards.get_users_managing_menu()
            )
        elif destination == "admins_managing":
            # Back to admins managing menu
            await query.edit_message_text(
                self.formatter._t('select_admin_management_option'),
                reply_markup=self.keyboards.get_admins_managing_menu()
            )
        elif destination == "help":
            await query.edit_message_text(
                self.formatter._t('help_menu'),
                reply_markup=self.keyboards.get_help_menu()
            )

    async def _handle_admin_selection(self, query, user_id):
        """Handle admin menu selections"""
        action = query.data.split("_")[1]
        admin_role = self.db_manager.get_admin_by_user_id(user_id=user_id)['role']

        if action == "tracking":
            print("i gocha")
            await query.edit_message_text(
                self.formatter._t('select_tracking_option'),
                reply_markup=self.keyboards.get_user_tracking_menu()
            )
            
        elif action == "users":
            if admin_role == AdminTypes.WATCHER:

                await query.edit_message_text(
                    self.formatter._t('not_authorized'),
                    reply_markup=self.keyboards.get_admin_menu()
                )
            else:
                await query.edit_message_text(
                    self.formatter._t('select_user_management_option'),
                    reply_markup=self.keyboards.get_users_managing_menu()
                )
        elif action == "admins":
            if admin_role == AdminTypes.MASTER:
                await query.edit_message_text(
                    self.formatter._t('select_admin_management_option'),
                    reply_markup=self.keyboards.get_admins_managing_menu()
                )
                
            else:
                await query.edit_message_text(
                    self.formatter._t('not_authorized'),
                    reply_markup=self.keyboards.get_admin_menu()
                )

    async def _handle_tracking_selection(self, query, user_id):
        """Handle user tracking selections"""
        action = query.data.split("_")[1]
        
        if action == "searched":
            searched_data = await self._get_most_searched_data()
            await query.edit_message_text(
                f"{self.formatter._t('most_searched_stats')}\n{searched_data}",
                reply_markup=self.keyboards.get_user_tracking_menu()
            )
            
        elif action == "analysis":
            analysis_data = await self._get_popular_analysis_data()
            await query.edit_message_text(
                f"{self.formatter._t('popular_analysis_stats')}\n{analysis_data}",
                reply_markup=self.keyboards.get_user_tracking_menu()
            )

    async def _handle_users_action(self, query, user_id):
        """Handle various user management actions"""
        action = query.data.split("_")[1]
        
        if action == "subscribe":
            self.user_states[user_id] = {"action": "awaiting_subscription_change"}
            await query.edit_message_text(
                self.formatter._t('provide_user_id_for_subscription')
            )
            
        elif action == "ban":
            self.user_states[user_id] = {"action": "awaiting_user_ban"}
            await query.edit_message_text(
                self.formatter._t('provide_user_id_for_ban')
            )

    async def _handle_back_button(self, query, user_id):
        """Handle back button presses"""
        destination = query.data.split("_")[1]
        
        if destination == "main":
            await query.edit_message_text(
                self.formatter._t('main_menu'),
                reply_markup=self.keyboards.get_main_menu()
            )
        elif destination == "analysis":
            await query.edit_message_text(
                self.formatter._t('select_analysis'),
                reply_markup=self.keyboards.get_analysis_menu()
            )
        elif destination == "admin":
            await query.edit_message_text(
                self.formatter._t('admin_menu'),
                reply_markup=self.keyboards.get_admin_menu()
            )

    async def _get_most_searched_data(self):
        try:
            return self.db_manager.get_most_popular_searches(10)
        except Exception as e:
            return str(e)

    async def _get_popular_analysis_data(self):
        try:
            return self.db_manager.get_most_popular_analysis_types(10)
        except Exception as e:
            return await str(e)

    async def _get_users_list(self):
        """Retrieve list of users"""
        return "Users list placeholder"
    
    async def _handle_admins_action(self, query, user_id):
        """Handle admin management actions"""
        action = query.data.split("_")[1]
        
        try:
            if action == "new":
                # Set state to await new admin ID
                self.user_states[user_id] = {
                    "action": "awaiting_new_admin_id"
                }
                await query.edit_message_text(
                    self.formatter._t('provide_new_admin_id'),
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(
                            text=self.formatter._t('back_button'),
                            callback_data="back_admin"
                        )
                    ]])
                )
                
            elif action == "change":
                # Set state to await admin ID for role change
                self.user_states[user_id] = {
                    "action": "awaiting_role_change_id"
                }
                await query.edit_message_text(
                    self.formatter._t('provide_admin_id_for_role_change'),
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(
                            text=self.formatter._t('back_button'),
                            callback_data="back_admin"
                        )
                    ]])
                )
                
                
            elif action == "delete":
                # Set state to await admin ID for deletion
                self.user_states[user_id] = {
                    "action": "awaiting_delete_admin_id"
                }
                await query.edit_message_text(
                    self.formatter._t('provide_admin_id_for_removal'),
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(
                            text=self.formatter._t('back_button'),
                            callback_data="back_admin"
                        )
                    ]])
                )

        except Exception as e:
            await query.answer(
                f"{self.formatter._t('error')}: {str(e)}"
            )

    async def _handle_user_ban(self,query,context,user_id):
            success = self.db_manager.update_user_type(context.args[0],new_type=UserType.BANNED)
            if success:
                await query.edit_message_text(
                f"{self.formatter._t('user ')} {context.args[0]} {self.formatter._t('was banned')}",
                reply_markup=self.keyboards.get_admin_menu()
                )
            else:
                await query.edit_message_text(
                self.formatter._t('somthing went wrong'))

    async def _handle_change_user_subscrption(self,query,context,user_id):
        subscription = query.data.split("_")[-1]

        success = self.db_manager.update_user_type(context.args[0],new_type=subscription)
        if success:
                await query.edit_message_text(
                f"{self.formatter._t('user ')} {context.args[0]} {self.formatter._t('subscription was changed')}",
                reply_markup=self.keyboards.get_admin_menu()
                )
        else:
            await query.edit_message_text(
            self.formatter._t('somthing went wrong'))

    async def _handle_admin_remove(self,query,context,user_id):
            success = self.db_manager.remove_admin(admin_id=context.args[0],removed_by=user_id)
            if success:
                await query.edit_message_text(
                f"{self.formatter._t('admin ')} {context.args[0]} {self.formatter._t('was removed')}",
                reply_markup=self.keyboards.get_admin_menu()
                )
            else:
                await query.edit_message_text(
                self.formatter._t('somthing went wrong'))


    async def _handle_admin_add(self,query,context,user_id):
            success = self.db_manager.create_admin(context.args[0],user_id)
            if success:
                await query.edit_message_text(
                f"{self.formatter._t('admin ')} {context.args[0]} {self.formatter._t('was added')}",
                reply_markup=self.keyboards.get_admin_menu()
                )
            else:
                await query.edit_message_text(
                self.formatter._t('somthing went wrong'))

    async def _handle_change_admin_role(self,query,context,user_id):
        role = query.data.split("_")[-1]
        
        # check if the chager has authoroity to do this
        admin = self.db_manager.get_admin_by_user_id(self.user_states['user_id'])
        if admin['role'] != 'master':
            return await query.edit_message_text(
            "self.formatter._t('you do not have authorization to this proccess')")
        
        success = self.db_manager.update_admin_role(context.args[0],new_role=role,updated_by=user_id)
        if success:
                await query.edit_message_text(
                f"{self.formatter._t('user ')} {context.args[0]} {self.formatter._t('subscription was changed')}",
                reply_markup=self.keyboards.get_admin_menu()
                )
        else:
            await query.edit_message_text(
            self.formatter._t('somthing went wrong'))
                   
        
            
    async def _handle_help_selection(self, query, user_id):
         """Handle help menu selections"""
         section = query.data.split("_")[1]
         
         if section == "intro":
             await query.edit_message_text(
                 self._get_help_intro_text(),
                 reply_markup=self.keyboards.get_help_sub_menu()
             )
         elif section == "commands":
             await query.edit_message_text(
                 self._get_help_commands_text(),
                 reply_markup=self.keyboards.get_help_sub_menu()
             )
         elif section == "navigation":
             await query.edit_message_text(
                 self._get_help_navigation_text(),
                 reply_markup=self.keyboards.get_help_sub_menu()
             )
         elif section == "analysis":
             await query.edit_message_text(
                 self._get_help_analysis_text(),
                 reply_markup=self.keyboards.get_help_sub_menu()
             )
         elif section == "charts":
             await query.edit_message_text(
                 self._get_help_charts_text(),
                reply_markup=self.keyboards.get_help_sub_menu()
             )
         elif section == "news":
            await query.edit_message_text(
                self._get_help_news_text(),
                reply_markup=self.keyboards.get_help_sub_menu()
             )
         elif section == "agent":
             await query.edit_message_text(
                 self._get_help_agent_text(),
                 reply_markup=self.keyboards.get_help_sub_menu()
             )
         elif section == "troubleshooting":
            await query.edit_message_text(
                 self._get_help_troubleshooting_text(),
                reply_markup=self.keyboards.get_help_sub_menu()
             )
         elif section == "settings":
             await query.edit_message_text(
                 self._get_help_settings_text(),
                 reply_markup=self.keyboards.get_help_sub_menu()
             )
         elif section == "feedback":
            await query.edit_message_text(
                 self._get_help_feedback_text(),
                reply_markup=self.keyboards.get_help_sub_menu()
             )
    
    async def _handle_education_selection(self, query, user_id):
        """Handle education menu selections"""
        sections = query.data.split("_")[1:]  # Get all parts after 'education'
        section = "_".join(sections)  # Rejoin to handle multi-part sections
        
        if section == "back":
            await query.edit_message_text(
                self.formatter._t('education_menu'),
                reply_markup=self.keyboards.get_education_menu()
            )
            return

        # For each topic, find matching entries in JSON
        topic_keys = []
        for key in self.formatter.languages[self.formatter.current_language].keys():
            if key.startswith(f"education_topic_{section}") and key.endswith("_title"):
                base_key = key.rsplit('_title', 1)[0]
                topic_keys.append(base_key)

        message_text = ""
        
        # Build message for each matching topic
        for base_key in topic_keys:
            title = self.formatter._t(f"{base_key}_title")
            text = self.formatter._t(f"{base_key}_text")
            
            message_text += f"*{title}*\n\n{text}\n\n"

            # Check for associated links
            link_counter = 1
            while True:
                link_text_key = f"{base_key}_link_{link_counter}_text"
                link_url_key = f"{base_key}_link_{link_counter}_url"
                
                link_text = self.formatter._t(link_text_key)
                link_url = self.formatter._t(link_url_key)
                
                if not (link_text and link_url):
                    break
                    
                message_text += f"[{link_text}]({link_url})\n"
                link_counter += 1

        await query.edit_message_text(
            message_text,
            reply_markup=self.keyboards.get_education_sub_menu(),
            parse_mode="Markdown"
        )
    # Existing helper methods: _get_help_intro_text, _get_help_commands_text
    # _get_help_navigation_text, _get_help_analysis_text, _get_help_charts_text
    # _get_help_news_text ,_get_help_agent_text , _get_help_troubleshooting_text,
    # _get_help_settings_text,  _get_help_feedback_text
    def _get_help_intro_text(self):
        """Returns the help intro text."""
        return self.formatter._t("help_intro_text")
    
    def _get_help_commands_text(self):
        """Returns the help commands text."""
        return self.formatter._t("help_commands_text")
    
    def _get_help_navigation_text(self):
        """Returns the help navigation text."""
        return self.formatter._t("help_navigation_text")

    def _get_help_analysis_text(self):
         """Returns the help analysis text."""
         return self.formatter._t("help_analysis_text")
    
    def _get_help_charts_text(self):
        """Returns the help charts text."""
        return self.formatter._t("help_charts_text")
    
    def _get_help_news_text(self):
         """Returns the help news text."""
         return self.formatter._t("help_news_text")
    
    def _get_help_agent_text(self):
        """Returns the help ai agent text."""
        return self.formatter._t("help_agent_text")
    
    def _get_help_troubleshooting_text(self):
        """Returns the help troubleshooting text."""
        return self.formatter._t("help_troubleshooting_text")

    def _get_help_settings_text(self):
        """Returns the help settings text."""
        return self.formatter._t("help_settings_text")
    
    def _get_help_feedback_text(self):
        """Returns the help feedback text."""
        return self.formatter._t("help_feedback_text")
</file>

<file path="bot\handlers\message_handler.py">
from telegram import Update
from telegram.ext import ContextTypes

from src.bot.keyboards.reply_keyboards import AnalysisKeyboards
from src.services.database_manager import DatabaseManager
from .analysis_handlers import AnalysisHandler
from ...llm.agent import CryptoAnalysisAgent
from ...utils.formatters import TelegramFormatter


class CustomMessageHandler:  # Renamed from MessageHandler to CustomMessageHandler
    def __init__(self):
        self.analysis_handler = AnalysisHandler()
        self.agent = CryptoAnalysisAgent()
        self.formatter = TelegramFormatter()
        self.db_manager = DatabaseManager()
        self.keyboards = AnalysisKeyboards()
        self.user_states = {}

    async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle text messages"""
        user_id = update.effective_user.id
        text = update.message.text.lower()

        # Set language from context
        if 'language' in context.user_data:
            self.formatter.set_language(context.user_data['language'])
        
        # Get user's current state
        state = self.user_states.get(user_id, {})
        
        if not state:
            # No active state, ignore the message or provide guidance
            loading_message = await update.message.reply_text(
            self.formatter._t('loading'))

            message = self.agent.process_query(text)
            print(message)
            await loading_message.edit_text(text=message['output'])
            return

        try:
            action = state.get('action')
            if action == 'quick_analysis':
                # Prepare context.args for quick analysis
                context.args = [text]
                await self.analysis_handler.cmd_quick(update, context)
            
            elif action == 'news_analysis':
                # Prepare context.args for quick analysis
                context.args = [text]
                await self.analysis_handler.cmd_news(update, context)
                
            elif action == 'full_analysis':
                # Create a context args list with symbol and timeframe
                context.args = [text]  # Symbol
                if 'timeframe' in state:
                    context.args.append(state['timeframe'])
                await self.analysis_handler.cmd_analyze(update, context)
                
            elif action == 'chart':
                # Create context args with symbol, chart type, and timeframe
                context.args = [
                    text,  # Symbol
                    state.get('type', 'price'),  # Chart type
                    state.get('timeframe', '1d')  # Timeframe
                ]
                await self.analysis_handler.cmd_chart(update, context)
            elif action == 'awaiting_user_ban':
                
                target_id = int(text)
                context.args = [target_id]
                user = self.db_manager.get_user_by_telegram_id(target_id)
                if user:
                    await update.message.reply_text(
                        f"{self.formatter._t('proceed with banning user: ')} {target_id}",
                        reply_markup=self.keyboards.get_user_ban_menu()
                    )
                else:
                    await update.message.reply_text(
                        f"{self.formatter._t('can not find user with user id: ')} {target_id}",
                        reply_markup=self.keyboards.get_admin_menu()
                    )
            elif action == 'awaiting_subscription_change':
                target_id = int(text)
                context.args = [target_id,]
                user = self.db_manager.get_user_by_telegram_id(target_id)
                if user:
                    await update.message.reply_text(
                        f"{self.formatter._t('user current subscription is')} {user['type']}\n {self.formatter._t('do you want to change it?')}",
                        reply_markup=self.keyboards.get_change_user_subscrption_menu()
                    )
                else:
                    await update.message.reply_text(
                        f"{self.formatter._t('can not find user with user id: ')} {target_id}",
                        reply_markup=self.keyboards.get_admin_menu()
                    )
            elif action == 'awaiting_delete_admin_id':
                target_id = int(text)
                context.args = [target_id]
                user = self.db_manager.get_admin_by_user_id(target_id)
                if user:
                    await update.message.reply_text(
                        f"{self.formatter._t('proceed with removing admin: ')} {target_id}",
                        reply_markup=self.keyboards.get_admin_remove_menu()
                    )
                else:
                    await update.message.reply_text(
                        f"{self.formatter._t('can not find admin with user id: ')} {target_id}",
                        reply_markup=self.keyboards.get_admin_menu()
                    )
            elif action == 'awaiting_new_admin_id':
                target_id = int(text)
                context.args = [target_id]
                user = self.db_manager.get_admin_by_user_id(target_id)
                if user:
                    await update.message.reply_text(
                        f"{self.formatter._t('proceed with adding admin: ')} {target_id}",
                        reply_markup=self.keyboards.get_admin_add_menu()
                    )
                else:
                    await update.message.reply_text(
                        f"{self.formatter._t('can not find user with user id: ')} {target_id}",
                        reply_markup=self.keyboards.get_admin_menu()
                    )
            elif action == 'awaiting_role_change_id':
                target_id = int(text)
                context.args = [target_id,]
                user = self.db_manager.get_admin_by_user_id(target_id)
                if user:
                    await update.message.reply_text(
                        f"{self.formatter._t('admin current subscribtion is')} {user['type']}\n {self.formatter._t('do you want to change it?')}",
                        reply_markup=self.keyboards.get_change_admin_role_menu()
                    )
                else:
                    await update.message.reply_text(
                        f"{self.formatter._t('can not find admin with user id: ')} {target_id}",
                        reply_markup=self.keyboards.get_change_admin_role_menu()
                    )
            # Clear the state after processing
            self.user_states.pop(user_id, None)

        except Exception as e:
            await update.message.reply_text(
                  f"{self.formatter._t('error_processing')}: {str(e)}"
            )
            self.user_states.pop(user_id, None)
</file>

<file path="bot\keyboards\reply_keyboards.py">
# src/bot/keyboards/reply_keyboards.py
from ...utils.formatters import TelegramFormatter
from telegram import InlineKeyboardButton, InlineKeyboardMarkup

class AnalysisKeyboards:
    def __init__(self):
        self.formatter = TelegramFormatter()

    def get_main_menu(self):
        """Create main menu keyboard"""
        keyboard = [
            [
                InlineKeyboardButton(text=self.formatter._t('analysis_button'), callback_data="menu_analysis"),
                InlineKeyboardButton(text=self.formatter._t('charts_button'), callback_data="menu_charts")
            ],
            [
                InlineKeyboardButton(text=self.formatter._t('help_button'), callback_data="menu_help"),
                InlineKeyboardButton(text=self.formatter._t('settings_button'), callback_data="menu_settings")
            ]
            ,
            [
                InlineKeyboardButton(text=self.formatter._t('education_button'), callback_data="menu_education")
            ]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    def get_analysis_menu(self):
        """Create analysis selection keyboard"""
        keyboard = [
            [InlineKeyboardButton(text=self.formatter._t('quick_analysis_button'), callback_data="analysis_quick")],
            [InlineKeyboardButton(text=self.formatter._t('full_analysis_button'), callback_data="analysis_full")],
            [InlineKeyboardButton(text=self.formatter._t('news_analysis_button'), callback_data="analysis_news")],
            [InlineKeyboardButton(text=self.formatter._t('custom_charts_button'), callback_data="analysis_custom")],
            [InlineKeyboardButton(text=self.formatter._t('back_button'), callback_data="back_main")]
        ]
        return InlineKeyboardMarkup(keyboard)

    def get_timeframe_selection(self):
        """Create timeframe selection keyboard"""
        keyboard = [
            [
                InlineKeyboardButton(text=self.formatter._t('time_1d'), callback_data="timeframe_1d"),
                InlineKeyboardButton(text=self.formatter._t('time_1w'), callback_data="timeframe_1w"),
                InlineKeyboardButton(text=self.formatter._t('time_1m'), callback_data="timeframe_1m"),
                InlineKeyboardButton(text=self.formatter._t('time_3m'), callback_data="timeframe_3m")
            ],
            [InlineKeyboardButton(text=self.formatter._t('back_button'), callback_data="back_analysis")]
        ]
        return InlineKeyboardMarkup(keyboard)

    def get_chart_types(self):
        """Create chart type selection keyboard"""
        keyboard = [
            [InlineKeyboardButton(text=self.formatter._t('price_chart'), callback_data="chart_price")],
            [InlineKeyboardButton(text=self.formatter._t('moving_averages'), callback_data="chart_ma")],
            [InlineKeyboardButton(text=self.formatter._t('macd'), callback_data="chart_macd")],
            [InlineKeyboardButton(text=self.formatter._t('rsi'), callback_data="chart_rsi")],
            [InlineKeyboardButton(text=self.formatter._t('volume_chart'), callback_data="chart_volume")],
            [InlineKeyboardButton(text=self.formatter._t('back_button'), callback_data="back_analysis")]
        ]
        return InlineKeyboardMarkup(keyboard)

    def get_settings_menu(self):
        """Create settings menu keyboard"""
        keyboard = [
            [InlineKeyboardButton(text=self.formatter._t('language_button'), callback_data="settings_language")],
            [InlineKeyboardButton(text=self.formatter._t('timeframe_button'), callback_data="settings_timeframe")],
            [InlineKeyboardButton(text=self.formatter._t('chart_type_button'), callback_data="settings_chart")],
            [InlineKeyboardButton(text=self.formatter._t('back_button'), callback_data="back_main")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    def get_help_menu(self):
        """Create help menu keyboard"""
        keyboard = [
            [InlineKeyboardButton(text=self.formatter._t('help_intro_button'), callback_data="help_intro")],
             [InlineKeyboardButton(text=self.formatter._t('help_commands_button'), callback_data="help_commands")],
           [InlineKeyboardButton(text=self.formatter._t('help_navigation_button'), callback_data="help_navigation")],
            [InlineKeyboardButton(text=self.formatter._t('help_analysis_button'), callback_data="help_analysis")],
           [InlineKeyboardButton(text=self.formatter._t('help_charts_button'), callback_data="help_charts")],
            [InlineKeyboardButton(text=self.formatter._t('help_news_button'), callback_data="help_news")],
           [InlineKeyboardButton(text=self.formatter._t('help_agent_button'), callback_data="help_agent")],
            [InlineKeyboardButton(text=self.formatter._t('help_troubleshooting_button'), callback_data="help_troubleshooting")],
           [InlineKeyboardButton(text=self.formatter._t('help_settings_button'), callback_data="help_settings")],
           [InlineKeyboardButton(text=self.formatter._t('help_feedback_button'), callback_data="help_feedback")],
           [InlineKeyboardButton(text=self.formatter._t('back_button'), callback_data="back_main")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    def get_help_sub_menu(self):
        """Create help sub-menu keyboard"""
        keyboard = [
             [InlineKeyboardButton(text=self.formatter._t('back_button'), callback_data="back_help")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    def get_education_menu(self):
        """Create education menu keyboard"""
        keyboard = [
            [InlineKeyboardButton(text=self.formatter._t('education_basic_concepts'), callback_data="education_basic_concepts")],
            [InlineKeyboardButton(text=self.formatter._t('education_technical_analysis'), callback_data="education_technical_analysis")],
            [InlineKeyboardButton(text=self.formatter._t('education_trading_strategies'), callback_data="education_trading_strategies")],
             [InlineKeyboardButton(text=self.formatter._t('education_defi_nfts'), callback_data="education_defi_nfts")],
              [InlineKeyboardButton(text=self.formatter._t('education_security'), callback_data="education_security")],
            [InlineKeyboardButton(text=self.formatter._t('back_button'), callback_data="back_main")]
        ]
        return InlineKeyboardMarkup(keyboard)
    

    def get_admin_menu(self):
        """Create admin menu keyboard"""
        keyboard = [
            [
                InlineKeyboardButton(text=self.formatter._t('users_tracking'), callback_data="admin_tracking"),
                InlineKeyboardButton(text=self.formatter._t('manage_users'), callback_data="admin_users"),
                InlineKeyboardButton(text=self.formatter._t('manage_admins'), callback_data="admin_admins")
            ],
            [InlineKeyboardButton(text=self.formatter._t('back_button'), callback_data="back_main")]
        ]
        return InlineKeyboardMarkup(keyboard)

    def get_user_tracking_menu(self):
        """Create user tracking menu keyboard"""
        keyboard = [
            [
                InlineKeyboardButton(text=self.formatter._t('most_searched'), callback_data="tracking_searched"),
                InlineKeyboardButton(text=self.formatter._t('popular_analysis'), callback_data="tracking_analysis"),
            ],
            [InlineKeyboardButton(text=self.formatter._t('back_button'), callback_data="back_admin")]
        ]
        return InlineKeyboardMarkup(keyboard)

    def get_users_managing_menu(self):
        """Create users managing menu keyboard"""
        keyboard = [
            [
                InlineKeyboardButton(text=self.formatter._t('change_subscription'), callback_data="users_subscribe"),
                InlineKeyboardButton(text=self.formatter._t('ban_user'), callback_data="users_ban"),
            ],
            [InlineKeyboardButton(text=self.formatter._t('back_button'), callback_data="back_admin")]
        ]
        return InlineKeyboardMarkup(keyboard)

    def get_user_ban_menu(self):
        """Create users ban menu keyboard"""
        keyboard = [
            [
                InlineKeyboardButton(text=self.formatter._t('yes'), callback_data="toggle_ban")
            ],
            [InlineKeyboardButton(text=self.formatter._t('back_button'), callback_data="back_admin")]
        ]  
        return InlineKeyboardMarkup(keyboard)  

    def get_change_user_subscrption_menu(self):
        """Create users subscription change menu keyboard"""
        keyboard = [
            [
                InlineKeyboardButton(text=self.formatter._t('guest'), callback_data=f"change_user_subscrption_guest"),
                InlineKeyboardButton(text=self.formatter._t('premium'), callback_data=f"change_user_subscrption_premium")
            ],
            [InlineKeyboardButton(text=self.formatter._t('back_button'), callback_data="back_admin")]
        ]  
        return InlineKeyboardMarkup(keyboard)  

    def get_admins_managing_menu(self):
        """Create admins managing menu keyboard"""
        keyboard = [
            [
                InlineKeyboardButton(text=self.formatter._t('new_admin'), callback_data="adminsconf_new"),
                InlineKeyboardButton(text=self.formatter._t('change_role'), callback_data="adminsconf_change"),
                InlineKeyboardButton(text=self.formatter._t('delete_admin'), callback_data="adminsconf_delete"),
            ],
            [InlineKeyboardButton(text=self.formatter._t('back_button'), callback_data="back_admin")]
        ]
        return InlineKeyboardMarkup(keyboard)

    def get_admin_remove_menu(self):
        """Create admin remove menu keyboard"""
        keyboard = [
            [
                InlineKeyboardButton(text=self.formatter._t('yes'), callback_data="remove_admin")
            ],
            [InlineKeyboardButton(text=self.formatter._t('back_button'), callback_data="back_admin")]
        ]  
        return InlineKeyboardMarkup(keyboard) 

    def get_admin_add_menu(self):
        """Create admin add menu keyboard"""
        keyboard = [
            [
                InlineKeyboardButton(text=self.formatter._t('yes'), callback_data="add_admin")
            ],
            [InlineKeyboardButton(text=self.formatter._t('back_button'), callback_data="back_admin")]
        ]  
        return InlineKeyboardMarkup(keyboard)   

    def get_change_admin_role_menu(self):
        """Create admin role change menu keyboard"""
        keyboard = [
            [
                InlineKeyboardButton(text=self.formatter._t('master'), callback_data=f"change_admin_master"),
                InlineKeyboardButton(text=self.formatter._t('normal'), callback_data=f"change_admin_normal"),
                InlineKeyboardButton(text=self.formatter._t('watcher'), callback_data=f"change_admin_watcher")
            ],
            [InlineKeyboardButton(text=self.formatter._t('back_button'), callback_data="back_admin")]
        ]  
        return InlineKeyboardMarkup(keyboard)

    def get_education_sub_menu(self, category_identifier):
        """Create education sub-menu keyboard for a specific category"""
        keyboard = []
        
        # Get all available keys that start with "education_[category_identifier]_" and ends with `_title`
        all_keys = self.formatter.languages[self.formatter.current_language].keys()
        module_keys = [key for key in all_keys if key.startswith(f"education_{category_identifier}_") and key.endswith("_title")]
        
        for key in module_keys:
            module_title = self.formatter._t(key)
            module_id = key.replace("_title", "") # get the full key up to the title
            keyboard.append([InlineKeyboardButton(text=module_title, callback_data=module_id)])
        
        # Add the back button
        keyboard.append([InlineKeyboardButton(text=self.formatter._t('back_button'), callback_data="back_education")])
        
        return InlineKeyboardMarkup(keyboard)
</file>

<file path="data\cc_news.py">
import requests
import pandas as pd
from datetime import datetime
from typing import Dict, List, Tuple, Optional

class CryptoNewsFetcher:
    def __init__(self, api_key: str):
        """
        Initialize the CryptoCompare News API client.
        
        Args:
            api_key (str): CryptoCompare API key
        """
        self.api_key = api_key
        self.base_url = "https://data-api.cryptocompare.com/news/v1/article"
    
    def _safe_timestamp_to_datetime(self, timestamp) -> Optional[datetime]:
        """
        Safely convert timestamp to datetime.
        
        Args:
            timestamp: Unix timestamp or None
            
        Returns:
            datetime or None if conversion fails
        """
        try:
            return datetime.fromtimestamp(timestamp) if timestamp else None
        except (TypeError, ValueError):
            return None
    
    def get_news_by_coin(self, 
                        categories: str,
                        limit: int = 10,
                        lang: str = "EN") -> Tuple[pd.DataFrame, bool]:
        """
        Get news articles related to specific cryptocurrency categories.
        
        Args:
            categories (str): Cryptocurrency categories (e.g., 'BTC,ETH')
            limit (int): Maximum number of news articles to fetch
            lang (str): Language of articles (default: 'EN')
            
        Returns:
            Tuple[pd.DataFrame, bool]: (DataFrame containing news articles, success status)
        """
        params = {
            'categories': categories,
            'lang': lang,
            'limit': limit,
            'api_key': self.api_key
        }
        
        headers = {
            'Content-type': 'application/json; charset=UTF-8'
        }
        
        try:
            response = requests.get(
                f"{self.base_url}/list",
                params=params,
                headers=headers
            )
            
            if response.status_code != 200:
                print(f"Error: API returned status code {response.status_code}")
                return pd.DataFrame(), False
                
            data = response.json()
            
            if not data.get('Data'):
                print("No news articles found")
                return pd.DataFrame(), False
            
            articles = []
            
            for article in data['Data']:
                try:
                    # Extract categories safely
                    category_data = article.get('CATEGORY_DATA', [])
                    categories = [cat.get('NAME', '') for cat in category_data if cat.get('NAME')]
                    
                    # Extract source data safely
                    source_data = article.get('SOURCE_DATA', {})
                    
                    articles.append({
                        'id': article.get('ID'),
                        'guid': article.get('GUID'),
                        'published_on': self._safe_timestamp_to_datetime(article.get('PUBLISHED_ON')),
                        'title': article.get('TITLE', ''),
                        'url': article.get('URL', ''),
                        'image_url': article.get('IMAGE_URL', ''),
                        'body': article.get('BODY', ''),
                        'tags': article.get('KEYWORDS', ''),
                        'categories': '|'.join(categories) if categories else '',
                        'language': article.get('LANG', ''),
                        'source_name': source_data.get('NAME', ''),
                        'source_url': source_data.get('URL', ''),
                        'upvotes': article.get('UPVOTES', 0),
                        'downvotes': article.get('DOWNVOTES', 0),
                        'sentiment': article.get('SENTIMENT', ''),
                        'created_on': self._safe_timestamp_to_datetime(article.get('CREATED_ON')),
                        'updated_on': self._safe_timestamp_to_datetime(article.get('UPDATED_ON'))
                    })
                except Exception as e:
                    print(f"Warning: Error processing article: {str(e)}")
                    continue
            
            if not articles:
                print("No valid articles found after processing")
                return pd.DataFrame(), False
            
            return pd.DataFrame(articles), True
            
        except Exception as e:
            print(f"Error fetching news: {str(e)}")
            return pd.DataFrame(), False
    
    def save_news(self, df: pd.DataFrame, filename: str) -> bool:
        """
        Save news DataFrame to CSV file.
        
        Args:
            df (pd.DataFrame): DataFrame containing news articles
            filename (str): Name of the file to save
            
        Returns:
            bool: True if save was successful, False otherwise
        """
        try:
            df.to_csv(filename, index=False, encoding='utf-8')
            print(f"Successfully saved news articles to {filename}")
            return True
        except Exception as e:
            print(f"Error saving news to CSV: {str(e)}")
            return False
    
    def get_news_stats(self, df: pd.DataFrame) -> Dict:
        """
        Get basic statistics about the news articles.
        
        Args:
            df (pd.DataFrame): DataFrame containing news articles
            
        Returns:
            Dict: Dictionary containing news statistics
        """
        if df.empty:
            return {}
        
        try:
            # Get all categories (split the '|' separated strings)
            all_categories = [
                cat for cats in df['categories'].dropna() 
                for cat in cats.split('|') if cats
            ]
            
            return {
                'total_articles': len(df),
                'unique_sources': df['source_name'].nunique(),
                'most_common_source': df['source_name'].mode().iloc[0] if not df['source_name'].empty else None,
                'earliest_article': df['published_on'].min(),
                'latest_article': df['published_on'].max(),
                'avg_upvotes': df['upvotes'].mean(),
                'total_upvotes': df['upvotes'].sum(),
                'sentiment_distribution': df['sentiment'].value_counts().to_dict(),
                'top_categories': pd.Series(all_categories).value_counts().head(5).to_dict() if all_categories else {}
            }
        except Exception as e:
            print(f"Error calculating statistics: {str(e)}")
            return {}
</file>

<file path="data\cc_test.py">
from cc_news import CryptoNewsFetcher
def test_crypto_news_fetcher():
    try:
        # Initialize with your API key
        api_key = ""
        fetcher = CryptoNewsFetcher(api_key)
        
        # Test fetching Bitcoin and Ethereum news
        print("Fetching BTC and ETH news...")
        news_df, success = fetcher.get_news_by_coin(
            categories="BTC",
            limit=10,
            lang="EN"
        )
        
        if success and not news_df.empty:
            print(f"\nFound {len(news_df)} news articles")
            
            # Save to CSV
            if fetcher.save_news(news_df, 'crypto_news.csv'):
                print("News saved successfully")
            
            # Get and print statistics
            stats = fetcher.get_news_stats(news_df)
            if stats:
                print("\nNews Statistics:")
                for key, value in stats.items():
                    print(f"{key}: {value}")
            
            # Print latest article details
            if not news_df.empty:
                latest_article = news_df.iloc[0]
                print("\nLatest Article:")
                print(f"Title: {latest_article['title']}")
                print(f"Source: {latest_article['source_name']}")
                print(f"Published: {latest_article['published_on']}")
                print(f"URL: {latest_article['url']}")
                print(f"Categories: {latest_article['categories']}")
                print(f"Sentiment: {latest_article['sentiment']}")
        else:
            print("No news articles were retrieved")
            
    except Exception as e:
        print(f"Error in test script: {str(e)}")

if __name__ == "__main__":
    test_crypto_news_fetcher()
</file>

<file path="data\crypto_data.py">
# src/data/crypto_data.py

from pycoingecko import CoinGeckoAPI
from typing import Dict, List, Optional, Union
import time
import logging
from functools import lru_cache

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
class CryptoDataClient:
    def __init__(self):
        
        self.cg = CoinGeckoAPI()
        self.logger = logging.getLogger(__name__)
        
    @lru_cache(maxsize=100)
    def get_coin_list(self) -> List[Dict]:
        """Get list of all supported coins."""
        try:
            return self.cg.get_coins_list()
        except Exception as e:
            self.logger.error(f"Error fetching coin list: {e}")
            return []

    async def get_coin_price(self, coin_id: str, vs_currency: str = 'usd') -> Optional[float]:
        """Get current price of a coin."""
        try:
            result = self.cg.get_price(ids=coin_id, vs_currencies=vs_currency)
            return result.get(coin_id, {}).get(vs_currency)
        except Exception as e:
            self.logger.error(f"Error fetching price for {coin_id}: {e}")
            return None

    async def get_coin_history(self, 
                             coin_id: str, 
                             days: str,
                             vs_currency: str = 'usd') -> Optional[Dict]:
        """Get historical market data."""
        try:
            return self.cg.get_coin_market_chart_by_id(
                id=coin_id,
                vs_currency=vs_currency,
                days=days
            )
        except Exception as e:
            self.logger.error(f"Error fetching history for {coin_id}: {e}")
            return None

    async def get_coin_info(self, coin_id: str) -> Optional[Dict]:
        """Get detailed information about a coin."""
        try:
            return self.cg.get_coin_by_id(
                id=coin_id,
                localization=False,
                tickers=False,
                market_data=True,
                community_data=False,
                developer_data=False
            )
        except Exception as e:
            self.logger.error(f"Error fetching coin info for {coin_id}: {e}")
            return None

    async def search_coin(self, query: str) -> List[Dict]:
        """Search for coins by name or symbol."""
        try:
            coin_list = self.get_coin_list()
            return [
                coin for coin in coin_list
                if query.lower() in coin['id'].lower() 
                or query.lower() in coin['symbol'].lower()
            ][:10]  # Return top 10 matches
        except Exception as e:
            self.logger.error(f"Error searching for {query}: {e}")
            return []
</file>

<file path="data\market_data.py">
# src/data/market_data.py

import pandas as pd
import numpy as np
import logging
from typing import Optional, Dict
from datetime import datetime, timedelta
from src.data.crypto_data import CryptoDataClient

class MarketDataProcessor:
    def __init__(self, crypto_client: CryptoDataClient):
        self.crypto_client = crypto_client

    async def get_ohlcv_data(self, 
                            coin_id: str, 
                            days: str = '30',
                            interval: str = 'daily') -> Optional[pd.DataFrame]:
        """Get OHLCV data in pandas DataFrame format."""
        try:
            history = await self.crypto_client.get_coin_history(coin_id, days)
            if not history:
                return None

            # Extract price and volume data
            prices = history.get('prices', [])
            volumes = history.get('total_volumes', [])

            # Create DataFrame
            df = pd.DataFrame(prices, columns=['timestamp', 'price'])
            df['volume'] = pd.DataFrame(volumes, columns=['timestamp', 'volume'])['volume']
            
            # Process timestamp
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
            df.set_index('timestamp', inplace=True)

            # Resample to get OHLCV
            ohlcv = df.resample('D').agg({
                'price': ['first', 'high', 'low', 'last'],
                'volume': 'sum'
            })

            # Clean up column names
            ohlcv.columns = ['open', 'high', 'low', 'close', 'volume']
            return ohlcv

        except Exception as e:
            logging.error(f"Error processing OHLCV data for {coin_id}: {e}")
            return None

    async def get_market_summary(self, coin_id: str) -> Optional[Dict]:
        """Get market summary including price changes and volume."""
        try:
            info = await self.crypto_client.get_coin_info(coin_id)
            if not info or 'market_data' not in info:
                return None

            market_data = info['market_data']
            return {
                'current_price': market_data.get('current_price', {}).get('usd'),
                'price_change_24h': market_data.get('price_change_percentage_24h'),
                'volume_24h': market_data.get('total_volume', {}).get('usd'),
                'market_cap': market_data.get('market_cap', {}).get('usd'),
                'high_24h': market_data.get('high_24h', {}).get('usd'),
                'low_24h': market_data.get('low_24h', {}).get('usd')
            }

        except Exception as e:
            logging.error(f"Error getting market summary for {coin_id}: {e}")
            return None
</file>

<file path="data\processor.py">
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import time
from typing import Dict, List, Optional, Tuple
import logging

from ..services.coingecko_api import CoinGeckoAPI
from ..services.cache_manager import CacheManager

class DataProcessor:
    def __init__(self):
        self.api = CoinGeckoAPI()
        self.cache_manager = CacheManager("sqlite:///crypto_cache.db")
        self.logger = logging.getLogger(__name__)


    def get_ohlcv_data(
        self, 
        coin_id: str, 
        vs_currency: str = 'usd',
        days: int = 30,
        interval: Optional[str] = 'daily'
    ) -> Optional[pd.DataFrame]:
        """
        Fetch and process OHLCV (Open, High, Low, Close, Volume) data.
        
        Args:
            coin_id: The coin identifier (e.g., 'bitcoin')
            vs_currency: The target currency (default: 'usd')
            days: Number of days of data to fetch (default: 30)
            interval: Data interval (default: 'daily')
            
        Returns:
            pandas.DataFrame with OHLCV data or None if error occurs
        """
        
        coin_id = self.cache_manager.get_coin_id_by_symbol(coin_id)
        if coin_id is None:
            self.logger.error(f"Coin ID not found for symbol: {coin_id}")
            return None
        # Calculate time range
        end_time = datetime.utcnow()
        start_time = end_time - timedelta(days=days)
        
        # Try to get data from cache
        cached_data = self.cache_manager.get_ohlcv_data(
            coin_id=coin_id,
            vs_currency=vs_currency,
            interval=days,
            start_time=start_time,
            end_time=end_time
        )
        
        if cached_data is not None:
            return cached_data

        try:
            # Get market chart data
            market_data = self.api.get_coin_market_chart(
                id=coin_id,
                vs_currency=vs_currency,
                days=days,
                interval=interval
            )

            # Get OHLC data
            ohlc_data = self.api.get_coin_ohlc(
                id=coin_id,
                vs_currency=vs_currency,
                days=days
            )

            # Process and combine the data
            df = self._process_market_data(market_data, ohlc_data)
            
            # Update cache
            self.cache_manager.update_ohlcv_data(
                coin_id=coin_id,
                vs_currency=vs_currency,
                interval=days,
                df=df
            )
            
            return df

        except Exception as e:
            self.logger.error(f"Error fetching data for {coin_id}: {str(e)}")
            return None

    def _process_market_data(self, market_data: Dict, ohlc_data: List) -> pd.DataFrame:
        """
        Process raw market data into a pandas DataFrame suitable for technical analysis.
        """
        # Convert OHLC data
        ohlc_df = pd.DataFrame(ohlc_data, columns=['timestamp', 'open', 'high', 'low', 'close'])
        ohlc_df['timestamp'] = pd.to_datetime(ohlc_df['timestamp'], unit='ms')
        ohlc_df.set_index('timestamp', inplace=True)

        # Process market data
        prices = pd.DataFrame(market_data['prices'], columns=['timestamp', 'price'])
        volumes = pd.DataFrame(market_data['total_volumes'], columns=['timestamp', 'volume'])
        market_caps = pd.DataFrame(market_data['market_caps'], columns=['timestamp', 'market_cap'])

        # Convert timestamps
        prices['timestamp'] = pd.to_datetime(prices['timestamp'], unit='ms')
        volumes['timestamp'] = pd.to_datetime(volumes['timestamp'], unit='ms')
        market_caps['timestamp'] = pd.to_datetime(market_caps['timestamp'], unit='ms')

        # Merge all data
        df = prices.merge(volumes, on='timestamp', how='outer')
        df = df.merge(market_caps, on='timestamp', how='outer')
        df.set_index('timestamp', inplace=True)

        # Combine with OHLC data
        final_df = pd.concat([ohlc_df, df[['volume', 'market_cap']]], axis=1)
        
        # Sort by timestamp and remove duplicates
        final_df.sort_index(inplace=True)
        final_df = final_df[~final_df.index.duplicated(keep='first')]

        # Fill any missing values
        final_df.fillna(method='ffill', inplace=True)
        
        return final_df

    def get_multiple_coins_data(
        self, 
        coin_ids: List[str], 
        vs_currency: str = 'usd',
        days: int = 30
    ) -> Dict[str, pd.DataFrame]:
        """
        Fetch data for multiple coins with rate limiting.
        """
        results = {}
        for coin_id in coin_ids:
            
            results[coin_id] = self.get_ohlcv_data(coin_id, vs_currency, days)
            time.sleep(1)  # Rate limiting
        return results

    def get_latest_price(self, coin_id: str, vs_currency: str = 'usd') -> Optional[float]:
        """
        Get the latest price for a coin.
        """
        try:
            coin_id = self.cache_manager.get_coin_id_by_symbol(coin_id)
            if coin_id is None:
                self.logger.error(f"Coin ID not found for symbol: {coin_id}")
                return None
            price_data = self.api.get_simple_price(
                ids=coin_id,
                vs_currencies=vs_currency
            )
            return price_data[coin_id][vs_currency]
        except Exception as e:
            self.logger.error(f"Error fetching price for {coin_id}: {str(e)}")
            return None


    def validate_coin_id(self, coin_id: str) -> bool:
        """
        Validate if a coin ID exists, checking cache first.
        """
        # Check cache first
        coins = self.get_available_coins()
        cached_metadata = self.cache_manager.get_coin_metadata(coin_id)
        if cached_metadata is not None:
            return True

        # If not in cache, check API
        try:
            search_result = self.api.search(coin_id)
            coins = search_result.get('coins', [])
            
            # If found, update cache
            for coin in coins:
                if coin['id'].lower() == coin_id.lower():
                    self.cache_manager.update_coin_metadata(coin)
                    return True
            for coin in coins:
                if coin['symbol'].lower() == coin_id.lower():
                    self.cache_manager.update_coin_metadata(coin)
                    return True
            return False
            
        except Exception as e:
            self.logger.error(f"Validation error: {str(e)}")
            return False

    def get_available_coins(self) -> List[Dict]:
        """Get list of available coins, updating cache if needed."""
        try:
            cached_coins = self.cache_manager.get_all_coins()
            if cached_coins:
                return cached_coins

            coins = self.api.get_coins_list()
            if coins:
                self.cache_manager.update_coins_list(coins)
            return coins

        except Exception as e:
            self.logger.error(f"Error fetching coin list: {str(e)}")
            return []
</file>

<file path="data\reddit_news.py">
import praw
from datetime import datetime
import pandas as pd
from typing import List, Dict, Optional, Tuple
from prawcore.exceptions import ResponseException, OAuthException

class RedditCryptoScraper:
    def __init__(self, client_id: str, client_secret: str, user_agent: str):
        """
        Initialize the Reddit API client in read-only mode.
        
        Args:
            client_id (str): Reddit API client ID
            client_secret (str): Reddit API client secret
            user_agent (str): User agent string for API requests
        """
        if not all([client_id, client_secret, user_agent]):
            raise ValueError("All credentials (client_id, client_secret, user_agent) must be provided")
            
        try:
            self.reddit = praw.Reddit(
                client_id=client_id,
                client_secret=client_secret,
                user_agent=user_agent,
                check_for_async=False,
                read_only=True  # Set to read-only mode
            )
        except Exception as e:
            raise ValueError(f"Failed to initialize Reddit client: {str(e)}")
        
    def get_crypto_posts(self, 
                        crypto_name: str, 
                        subreddits: List[str], 
                        start_date: datetime,
                        limit: int = 100) -> Tuple[pd.DataFrame, bool]:
        """
        Get posts related to a specific cryptocurrency from given subreddits.
        
        Args:
            crypto_name (str): Name of the cryptocurrency (e.g., "bitcoin", "ethereum")
            subreddits (List[str]): List of subreddit names to search
            start_date (datetime): Start date for post collection
            limit (int): Maximum number of posts to fetch per subreddit
            
        Returns:
            Tuple[pd.DataFrame, bool]: (DataFrame containing post information, success status)
        """
        if not crypto_name or not subreddits:
            raise ValueError("Both crypto_name and subreddits must be provided")
            
        posts_data = []
        success = False
        
        for subreddit_name in subreddits:
            try:
                subreddit = self.reddit.subreddit(subreddit_name)
                
                # Test if we can access the subreddit
                subreddit.created_utc
                
                # Search for posts containing the crypto name
                for post in subreddit.search(crypto_name, sort='new', time_filter='all', limit=limit):
                    post_date = datetime.fromtimestamp(post.created_utc)
                    
                    if post_date >= start_date:
                        try:
                            posts_data.append({
                                'post_id': post.id,
                                'title': post.title,
                                'text': post.selftext,
                                'score': post.score,
                                'url': post.url,
                                'created_utc': post_date,
                                'author': str(post.author),
                                'num_comments': post.num_comments,
                                'subreddit': subreddit_name,
                                'upvote_ratio': post.upvote_ratio
                            })
                            success = True
                        except AttributeError as e:
                            print(f"Warning: Skipping post due to missing attribute: {e}")
                            continue
                            
            except Exception as e:
                print(f"Warning: Failed to fetch posts from r/{subreddit_name}: {str(e)}")
                continue
                
        if not posts_data:
            print(f"Warning: No posts found for {crypto_name} in the specified subreddits")
            return pd.DataFrame(), success
            
        return pd.DataFrame(posts_data), success
    
    def get_post_comments(self, post_id: str, limit: Optional[int] = None) -> pd.DataFrame:
        """
        Get comments for a specific post.
        
        Args:
            post_id (str): Reddit post ID
            limit (int, optional): Maximum number of comments to fetch
            
        Returns:
            pd.DataFrame: DataFrame containing comment information
        """
        if not post_id:
            raise ValueError("post_id must be provided")
            
        comments_data = []
        
        try:
            submission = self.reddit.submission(id=post_id)
            
            # Replace MoreComments objects with actual comments
            submission.comments.replace_more(limit=limit)
            
            for comment in submission.comments.list():
                try:
                    comments_data.append({
                        'comment_id': comment.id,
                        'post_id': post_id,
                        'text': comment.body,
                        'score': comment.score,
                        'created_utc': datetime.fromtimestamp(comment.created_utc),
                        'author': str(comment.author),
                        'is_submitter': comment.is_submitter,
                        'parent_id': comment.parent_id
                    })
                except AttributeError as e:
                    print(f"Warning: Skipping comment due to missing attribute: {e}")
                    continue
                    
        except Exception as e:
            print(f"Error fetching comments: {str(e)}")
            return pd.DataFrame()
            
        return pd.DataFrame(comments_data)
    
    def analyze_sentiment(self, df: pd.DataFrame, text_column: str) -> pd.DataFrame:
        """
        Add basic sentiment analysis to the DataFrame.
        
        Args:
            df (pd.DataFrame): DataFrame containing text data
            text_column (str): Name of the column containing text to analyze
            
        Returns:
            pd.DataFrame: DataFrame with added sentiment columns
        """
        try:
            from textblob import TextBlob
        except ImportError:
            raise ImportError("Please install textblob package: pip install textblob")
            
        df = df.copy()
        
        def get_sentiment(text):
            if pd.isna(text) or text == '':
                return 0
            return TextBlob(text).sentiment.polarity
            
        df['sentiment'] = df[text_column].apply(get_sentiment)
        return df
</file>

<file path="data\test.py">
from reddit_news import RedditCryptoScraper
from datetime import datetime, timedelta, timezone
import pandas as pd
from x_news import TwitterCryptoScraper
# Initialize the scraper with your Twitter API bearer token
scraper = TwitterCryptoScraper(
    bearer_token='AAAAAAAAAAAAAAAAAAAAAGxpxgEAAAAAvswnYGx52TllBHPvW%2BrBCcO%2BXiM%3DJejS5cVhUTSnegWyXRUwccr7a8fn4UKRdkoopMEPQnntjQft7l'
)

# Set parameters
crypto_name = "bitcoin"
start_time = datetime.now(timezone.utc) - timedelta(days=7)  # Last 7 days

# Get tweets
tweets_df, success = scraper.get_crypto_tweets(
    crypto_name=crypto_name,
    start_time=start_time,
    max_results=10
)

# Save tweets if successful
if success and not tweets_df.empty:
    scraper.save_tweets(tweets_df, 'bitcoin_tweets.csv')

# # Initialize the scraper
# scraper = RedditCryptoScraper(
#     client_id = "rPojxiOO1M1_1HVS31f-zg",
#     client_secret = "TPpmfycGPXS4vZnR9jJRORxbjvPXmQ",
#     user_agent = "python:mycryptoapp:v1.0 (by /u/Osman_Fox_1993)"
# )

# # Define parameters
# crypto_name = "BTC"
# subreddits = ["Altcoin", "CryptoCurrency", "CryptoMarkets"]
# start_date = datetime.now() - timedelta(days=7)

# # Get posts
# posts_df, success  = scraper.get_crypto_posts(
#     crypto_name=crypto_name,
#     subreddits=subreddits,
#     start_date=start_date
# )

# # Get comments for a specific post
# if success and not posts_df.empty:
#     comments_df = scraper.get_post_comments(posts_df['post_id'].iloc[0])
#     print(f"Found {len(comments_df)} comments")
# else:
#     print("No posts found to fetch comments from")

# # Add sentiment analysis
# posts_with_sentiment = scraper.analyze_sentiment(posts_df, 'text')
# comments_with_sentiment = scraper.analyze_sentiment(comments_df, 'text')
# posts_with_sentiment.to_csv('posts_sentiment.csv')
# comments_with_sentiment.to_csv('comments_sentiment.csv')
# print(posts_with_sentiment)
# print(comments_with_sentiment)
</file>

<file path="data\x_news.py">
import tweepy
import pandas as pd
from datetime import datetime, timezone
from typing import List, Dict, Optional, Tuple

class TwitterCryptoScraper:
    def __init__(self, bearer_token: str):
        """
        Initialize the Twitter API client.
        
        Args:
            bearer_token (str): Twitter API Bearer Token
        """
        if not bearer_token:
            raise ValueError("Bearer token must be provided")
            
        try:
            self.client = tweepy.Client(
                bearer_token=bearer_token,
                wait_on_rate_limit=True
            )
        except Exception as e:
            raise ValueError(f"Failed to initialize Twitter client: {str(e)}")
    
    def get_crypto_tweets(self, 
                         crypto_name: str,
                         start_time: datetime,
                         max_results: int = 100,
                         include_cashtags: bool = True) -> Tuple[pd.DataFrame, bool]:
        """
        Get tweets related to a specific cryptocurrency.
        
        Args:
            crypto_name (str): Name of the cryptocurrency (e.g., "bitcoin", "ethereum")
            start_time (datetime): Start time for tweet collection
            max_results (int): Maximum number of tweets to fetch (default: 100)
            include_cashtags (bool): Whether to include cashtag search (e.g., $BTC)
            
        Returns:
            Tuple[pd.DataFrame, bool]: (DataFrame containing tweet information, success status)
        """
        if not crypto_name:
            raise ValueError("crypto_name must be provided")
            
        tweets_data = []
        success = False
        
        try:
            # Prepare search query
            query_parts = [crypto_name]
            
            # Add cashtag if requested
            if include_cashtags:
                # Common cashtag mappings
                cashtag_map = {
                    'bitcoin': 'BTC',
                    'ethereum': 'ETH',
                    'binance': 'BNB',
                    'cardano': 'ADA',
                    'solana': 'SOL',
                    'ripple': 'XRP',
                    'dogecoin': 'DOGE',
                    'polkadot': 'DOT'
                }
                if crypto_name.lower() in cashtag_map:
                    query_parts.append(f"${cashtag_map[crypto_name.lower()]}")
            
            # Combine query parts
            query = " OR ".join(query_parts)
            
            # Add filters for better quality tweets
            query += " -is:retweet lang:en"
            
            # Search tweets
            tweets = self.client.search_recent_tweets(
                query=query,
                start_time=start_time,
                max_results=max_results,
                tweet_fields=['created_at', 'public_metrics', 'lang', 'source'],
                user_fields=['username', 'name', 'public_metrics'],
                expansions=['author_id']
            )
            
            if not tweets.data:
                print(f"No tweets found for {crypto_name}")
                return pd.DataFrame(), success
            
            # Create user lookup dictionary
            users = {user.id: user for user in tweets.includes['users']}
            
            # Process tweets
            for tweet in tweets.data:
                user = users.get(tweet.author_id)
                if user:
                    tweets_data.append({
                        'tweet_id': tweet.id,
                        'text': tweet.text,
                        'created_at': tweet.created_at,
                        'retweet_count': tweet.public_metrics['retweet_count'],
                        'reply_count': tweet.public_metrics['reply_count'],
                        'like_count': tweet.public_metrics['like_count'],
                        'quote_count': tweet.public_metrics['quote_count'],
                        'source': tweet.source,
                        'lang': tweet.lang,
                        'author_id': tweet.author_id,
                        'author_username': user.username,
                        'author_name': user.name,
                        'author_followers': user.public_metrics['followers_count'],
                        'author_following': user.public_metrics['following_count'],
                        'author_tweet_count': user.public_metrics['tweet_count']
                    })
            
            success = True
            
        except Exception as e:
            print(f"Error fetching tweets: {str(e)}")
            return pd.DataFrame(), success
        
        return pd.DataFrame(tweets_data), success
    
    def save_tweets(self, df: pd.DataFrame, filename: str) -> bool:
        """
        Save tweets DataFrame to CSV file.
        
        Args:
            df (pd.DataFrame): DataFrame containing tweets
            filename (str): Name of the file to save
            
        Returns:
            bool: True if save was successful, False otherwise
        """
        try:
            df.to_csv(filename, index=False, encoding='utf-8')
            print(f"Successfully saved tweets to {filename}")
            return True
        except Exception as e:
            print(f"Error saving tweets to CSV: {str(e)}")
            return False
</file>

<file path="education\content.py">
# src/education/content.py
educational_content = {
    "education_basic_concepts_introduction": {
        "title": "Introduction to Blockchain",
        "text": "A blockchain is a shared, immutable ledger that facilitates the process of recording transactions and tracking assets in a business network.",
        "links": [("Learn more about Blockchain", "https://www.ibm.com/topics/blockchain")]
    },
    "education_basic_concepts_cryptocurrencies": {
        "title": "Understanding Cryptocurrencies",
        "text": "A cryptocurrency is a digital or virtual currency secured by cryptography, which makes it nearly impossible to counterfeit or double-spend. Many cryptocurrencies are decentralized networks based on blockchain technology.",
        "links": [("Learn more about Cryptocurrencies", "https://www.investopedia.com/terms/c/cryptocurrency.asp")]
    },
    "education_basic_concepts_wallets": {
        "title": "Understanding Crypto Wallets",
        "text": "A cryptocurrency wallet is a device, physical medium, program or a service which stores the public and/or private keys for cryptocurrency transactions.",
        "links": [("Learn more about Crypto Wallets", "https://www.investopedia.com/terms/c/cryptocurrency-wallet.asp")]
    },
    "education_basic_concepts_exchanges": {
        "title": "Understanding Crypto Exchanges",
        "text": "A cryptocurrency exchange, or a digital currency exchange, is a business that allows customers to trade cryptocurrencies or digital currencies for other assets, such as conventional fiat money or other digital currencies.",
        "links": [("Learn more about Crypto Exchanges", "https://www.investopedia.com/terms/c/cryptocurrencyexchange.asp")]
    },
     "education_technical_analysis_moving_averages": {
        "title": "Moving Averages (MA)",
        "text": "Moving averages smooth out price data to make it easier to identify the trend. There are different types of MA such as the SMA, EMA, etc"
    },
    "education_technical_analysis_rsi_indicator": {
        "title": "Relative Strength Index (RSI)",
        "text": "The Relative Strength Index (RSI) is a momentum indicator that measures the magnitude of recent price changes to evaluate overbought or oversold conditions in the price of a stock or other asset.",
         "links": [("Learn more about RSI", "https://www.investopedia.com/terms/r/rsi.asp")]
    },
    "education_technical_analysis_macd_indicator": {
        "title": "Moving Average Convergence Divergence (MACD)",
        "text": "The Moving Average Convergence Divergence (MACD) is a trend-following momentum indicator that shows the relationship between two moving averages of a securitys price.",
        "links": [("Learn more about MACD", "https://www.investopedia.com/terms/m/macd.asp")]
    },
    "education_technical_analysis_bollinger_bands": {
        "title": "Bollinger Bands",
         "text": "Bollinger Bands are volatility bands placed above and below a moving average. Volatility is based on standard deviation, which changes as volatility increases and decreases. "
    },
     "education_technical_analysis_support_resistance":{
        "title":"Support and Resistance",
        "text": "Support and resistance levels are key areas where price movements are expected to slow or reverse. Support refers to the price level where buying pressure is expected to prevent a price decline, while resistance refers to the price level where selling pressure is expected to prevent a price increase."
     },
    "education_trading_strategies_day_trading":{
        "title": "Day Trading",
        "text":"Day trading is a type of trading in which you buy and sell positions within the same day to profit from small price movements."
    },
      "education_trading_strategies_swing_trading":{
        "title":"Swing Trading",
        "text":"Swing trading is a strategy that involves holding assets for a few days or weeks to capture profits from expected price swings."
    },
    "education_defi_nfts_what_is_defi": {
          "title":"What is DeFi?",
          "text": "DeFi, or Decentralized Finance, uses blockchain technology to offer financial services without centralized intermediaries like banks and financial institutions."
        },
    "education_defi_nfts_what_is_nft":{
        "title":"What are NFTs?",
        "text": "A non-fungible token (NFT) is a unique digital asset representing a wide range of tangible and intangible items, such as artworks, collectibles, and in-game items."
    },
   "education_security_scams": {
        "title":"Common Crypto Scams",
        "text":"There are many crypto scams such as phishing, ponzi schemes and pump and dumps. Always do your own research before you invest."
     }
}


def get_module_by_key(key):
    """
    Get the module by its key
    Args:
         key: a key
    Returns:
         dict: the module info
    """
    if key in educational_content:
       return educational_content[key]
    else:
       return None
</file>

<file path="languages\ar\messages.json">
{
  "error_analysis": "  ",
  "analysis_for": " ",
  "analyzing": "    ",
  "error": "",
  "loading": "   ...",
  "current_price": " ",
  "price_change": " ",
  "change": "",
  "high": "",
  "low": "",
  "volume": "",
  "trend_analysis": " ",
  "momentum_analysis": " ",
  "volume_analysis": " ",
  "volatility_analysis": " ",
  "support_resistance": " ",
  "risk_assessment": " ",
  "summary": "",
  "trend_signal": " ",
  "trend_strength": " ",
  "moving_averages": " ",
  "macd": "MACD",
  "rsi": "RSI",
  "stochastic": "",
  "volume_trend": " ",
  "bollinger_bands": " ",
  "historical_volatility": " ",
  "overbought": " ",
  "oversold": " ",
  "neutral": "",
  "strong": "",
  "weak": "",
  "resistance_at": " ",
  "support_at": " ",
  "next_resistance": " ",
  "next_support": " ",
  "risk_level": " ",
  "volatility_level": " ",
  "market_strength": " ",
  "very_high_risk": "  ",
  "high_risk": " ",
  "medium_risk": " ",
  "low_risk": " ",
  "signal": "",
  "overall_sentiment": " ",
  "confidence": " ",
  "key_signals": " ",
  "strong_buy": " ",
  "buy": "",
  "sell": "",
  "strong_sell": " ",
  "hold": "",
  "provide_symbol_prompt": "    ",
  "analyze_example": ": /analyze btc",
  "timeframe_optional": ":    /analyze btc 1w",
  "invalid_symbol": "    ",
  "invalid_timeframe": "   .  : 1d  1w  1m  3m",
  "price_chart": " ",
  "volume_chart": " ",
  "macd_chart": " MACD",
  "rsi_chart": " RSI",
  "news_summary": " ",
  "statistics": "",
  "latest_news": " ",
  "source": "",
  "published_on": " ",
  "total_articles": " ",
  "sentiment": "",
  "back_to_menu": "  ",
  "select_timeframe": "  ",
  "select_analysis": "  ",
  "refresh": "",
  "bot_help": "    ",
  "analysis_commands": " ",
  "specific_chart": " ",
  "available_chart_types": "  ",
  "select_settings": "  ",
  "timeframe_set": "    ",
  "selected_chart": " ",
  "language_updated": "   ",
  "main_menu": " ",
  "select_chart_type": "  ",
  "time_1d": " ",
  "time_1w": " ",
  "time_1m": " ",
  "time_3m": "3 ",
  "ma_chart": "  ",
  "try_different_symbol": "   ",
  "quick_example": ": /quick btc",
  "error_processing": "   ",
  "api_key_required": "    Google ",
  "quick_analysis_tool_desc": "      ",
  "news_analysis_tool_desc": "    ",
  "explain_indicator_tool_desc": "   ",
  "invalid_timeframe_prompt": "   . : 1d  1w  1m  3m",
  "invalid_symbol_prompt": "    ",
  "analysis_prompt": " {coin_id}  {timeframe}:\n{analysis}",
  "news_analysis_prompt": "    {query}:\n{news}",
  "indicator_explanation_prompt": "   {indicator}    ",
  "query_parse_error": "    .   :\n- '  BTC'\n- '   ETH'",
  "query_error": "   : {error}",
  "no_news_found": "      {symbol}",
  "analysis_error": "  : {error}",
  "date_label": "",
  "price_label": "",
  "volume_label": "",
  "price_chart_title": " ",
  "ma_chart_title": "  ",
  "macd_chart_title": " MACD",
  "rsi_chart_title": " RSI",
  "volume_chart_title": " ",
  "ma20_label": "   20 ",
  "ma50_label": "   50 ",
  "ma200_label": "   200 ",
  "macd_line": " MACD",
  "signal_line": " ",
  "histogram": " ",
   "open_price": "",
  "high_price": "",
  "low_price": "",
  "close_price": "",
   "analysis_button": " ",
  "charts_button": "  ",
  "help_button": " ",
  "settings_button": " ",
  "education_button": " ",
  "quick_analysis_button": "  ",
  "full_analysis_button": "  ",
  "news_analysis_button": "  ",
  "custom_charts_button": "   ",
  "back_button": " ",
   "language_button": "  ",
  "timeframe_button": "   ",
 "chart_type_button": "    ",
   "generating_chart_progress": "  : [{}] {}%",
  "chart_complete": "  ",
  "error_generating_chart": "   ",
  "provide_symbol_and_chart": "    ",
  "chart_example": ": /chart btc price",
   "help_intro_button": " ",
  "help_commands_button": " ",
 "help_navigation_button": " ",
 "help_analysis_button": " ",
 "help_charts_button": "  ",
  "help_news_button": " ",
  "help_agent_button": "  ",
  "help_troubleshooting_button": "   ",
  "help_settings_button": " ",
  "help_feedback_button": " ",
  "help_menu": " ",
  "help_intro_text":"     CryptoAnalyst!         . \n\n      !",
  "help_commands_text":"   :\n\n/start:      \n/analyze [symbol] [timeframe ()]:    .\n/quick [symbol]:      .\n/chart [symbol] [type] [timeframe ()]:   .\n/news [symbol]:      .",
  "help_navigation_text":"     .\n\n      .\n         .\n         .",
   "help_analysis_text":"    .\n\n :   /quick           .\n :   /analyze           .\n :   /chart             .",
    "help_charts_text":"      :\n\n :   \n  :     \n MACD:  MACD  \n RSI:  RSI  \n :     ",
 "help_news_text":"     .\n\n  /news             .\n      .",
      "help_agent_text":"     .\n\n         .\n\n:\n-   BTC\n-  RSI\n-     ",
  "help_troubleshooting_text":"      :\n\n  :         \n   :        : 1d  1w  1m  3m.\n  :        .",
  "help_settings_text":"    :\n\n:     .\n  :       .\n  :    .",
  "help_feedback_text":"                .",
   "education_menu": "  ",
   "education_basic_concepts": "  ",
  "education_technical_analysis": "  ",
   "education_trading_strategies":"  ",
  "education_defi_nfts": " DeFi  NFTs",
  "education_security": " ",
"education_topic_basic_concepts_introduction_title": "  ",
"education_topic_basic_concepts_introduction_text":"                  .",
    "education_topic_basic_concepts_introduction_link_1_text": "    ",
  "education_topic_basic_concepts_introduction_link_1_url": "https://www.ibm.com/topics/blockchain",
"education_topic_basic_concepts_cryptocurrencies_title":"  ",
 "education_topic_basic_concepts_cryptocurrencies_text":"                  .             .",
 "education_topic_basic_concepts_cryptocurrencies_link_1_text": "    ",
    "education_topic_basic_concepts_cryptocurrencies_link_1_url": "https://www.investopedia.com/terms/c/cryptocurrency.asp",
 "education_topic_basic_concepts_wallets_title":"   ",
 "education_topic_basic_concepts_wallets_text":"               /    .",
 "education_topic_basic_concepts_wallets_link_1_text": "     ",
  "education_topic_basic_concepts_wallets_link_1_url": "https://www.investopedia.com/terms/c/cryptocurrency-wallet.asp",
 "education_topic_basic_concepts_exchanges_title":"    ",
 "education_topic_basic_concepts_exchanges_text":"                            .",
    "education_topic_basic_concepts_exchanges_link_1_text": "      ",
    "education_topic_basic_concepts_exchanges_link_1_url": "https://www.investopedia.com/terms/c/cryptocurrencyexchange.asp",
  "education_topic_technical_analysis_moving_averages_title":"  (MA)",
   "education_topic_technical_analysis_moving_averages_text":"        .        SMA  EMA   .",
   "education_topic_technical_analysis_rsi_indicator_title":"   (RSI)",
  "education_topic_technical_analysis_rsi_indicator_text":"   (RSI)                     .",
    "education_topic_technical_analysis_rsi_indicator_link_1_text": "     ",
  "education_topic_technical_analysis_rsi_indicator_link_1_url": "https://www.investopedia.com/terms/r/rsi.asp",
  "education_topic_technical_analysis_macd_indicator_title":"    (MACD)",
  "education_topic_technical_analysis_macd_indicator_text":"    (MACD)            .",
      "education_technical_analysis_macd_indicator_link_1_text": "   MACD",
  "education_technical_analysis_macd_indicator_link_1_url": "https://www.investopedia.com/terms/m/macd.asp",
  "education_topic_technical_analysis_bollinger_bands_title":" ",
    "education_topic_technical_analysis_bollinger_bands_text":"         .           .",
     "education_topic_technical_analysis_support_resistance_title":" ",
    "education_topic_technical_analysis_support_resistance_text":"             .                             .",
   "education_topic_trading_strategies_day_trading_title":" ",
  "education_topic_trading_strategies_day_trading_text":"                  .",
  "education_topic_trading_strategies_swing_trading_title":" ",
    "education_topic_trading_strategies_swing_trading_text":"                .",
  "education_defi_nfts_what_is_defi_title":"  DeFi",
     "education_topic_defi_nfts_what_is_defi_text":" DeFi                .",
  "education_topic_defi_nfts_what_is_nft_title":"  NFTs",
  "education_topic_defi_nfts_what_is_nft_text":"    (NFT)                   .",
   "education_security_scams_title":"     ",
  "education_security_scams_text":"               .         .",
 "back_education": "   "
}
</file>

<file path="languages\en\messages.json">
{
    "welcome_text":"Welcome to CryptoAnalyst Bot! \n\nI can help you analyze cryptocurrencies with technical analysis and charts. Select an option below to get started:\nOr enter your text and let the agent help you out !",
    "error_analysis": " Analysis Error",
    "analysis_for": " Analysis for",
    "analyzing": " Analyzing cryptocurrency data...",
    "error": " Error",
    "loading": " Loading, please wait...",

    "current_price": " Current Price",
    "price_change": " Price Change",
    "change": " Change",
    "high": " High",
    "low": " Low",
    "volume": " Volume",

    "trend_analysis": " Trend Analysis",
    "momentum_analysis": " Momentum Analysis",
    "volume_analysis": " Volume Analysis",
    "volatility_analysis": " Volatility Analysis",
    "support_resistance": " Support & Resistance",
    "risk_assessment": " Risk Assessment",
    "summary": " Summary",

    "trend_signal": " Trend Signal",
    "trend_strength": " Trend Strength",
    "moving_averages": " Moving Averages",
    "macd": " MACD",
    "rsi": " RSI",
    "stochastic": " Stochastic",
    "volume_trend": " Volume Trend",
    "bollinger_bands": " Bollinger Bands",
    "historical_volatility": " Historical Volatility",

    "overbought": " Overbought",
    "oversold": " Oversold",
    "neutral": " Neutral",
    "strong": " Strong",
    "weak": " Weak",

    "resistance_at": " Resistance at",
    "support_at": " Support at",
    "next_resistance": " Next resistance",
    "next_support": " Next support",

    "risk_level": " Risk Level",
    "volatility_level": " Volatility Level",
    "market_strength": " Market Strength",
    "very_high_risk": " Very High Risk",
    "high_risk": " High Risk",
    "medium_risk": " Medium Risk",
    "low_risk": " Low Risk",

    "signal": " Signal",
    "overall_sentiment": " Overall Sentiment",
    "confidence": " Confidence Level",
    "key_signals": " Key Signals",
    "strong_buy": " Strong Buy",
    "buy": " Buy",
    "sell": " Sell",
    "strong_sell": " Strong Sell",
    "hold": " Hold",

    "provide_symbol_prompt": " Please provide a cryptocurrency symbol",
    "analyze_example": " Example: /analyze btc",
    "timeframe_optional": " Optional: Add timeframe /analyze btc 1w",
    "invalid_symbol": " Invalid cryptocurrency symbol",
    "invalid_timeframe": " Invalid timeframe. Please use: 1d, 1w, 1m, or 3m",

    "price_chart": " Price Chart",
    "volume_chart": " Volume Chart",
    "macd_chart": " MACD Chart",
    "rsi_chart": " RSI Chart",

    "news_summary": " News Summary",
    "statistics": " Statistics",
    "latest_news": " Latest News",
    "source": " Source",
    "published_on": " Published on",
    "total_articles": " Total Articles",
    "sentiment": " Sentiment",

    "back_to_menu": " Back to Menu",
    "select_timeframe": " Select Timeframe",
    "select_analysis": " Select Analysis Type",
    "refresh": " Refresh",

    "bot_help": " CryptoAnalyst Bot Help",
    "analysis_commands": " Analysis Commands",
    "specific_chart": " Specific Chart",
    "available_chart_types": " Available Chart Types",
    "select_settings": " Select Setting to Modify",
    "timeframe_set": " Timeframe set to",
    "selected_chart": " Selected chart",
    "language_updated": " Language Updated Successfully",
    "main_menu": " Main Menu",
    "select_chart_type": " Select Chart Type",
    "time_1d": " 1 Day",
    "time_1w": " 1 Week",
    "time_1m": " 1 Month",
    "time_3m": " 3 Months",

    "ma_chart": " Moving Averages Chart",

    "try_different_symbol": " Please try a different symbol",
    "quick_example": " Example: /quick btc",
    "error_processing": " Error Processing Request",

    "api_key_required": " Google API key is required",
    "quick_analysis_tool_desc": " Analyze cryptocurrency prices with technical indicators",
    "news_analysis_tool_desc": " Analyze crypto news and sentiment",
    "explain_indicator_tool_desc": " Explain technical analysis indicators",
    "invalid_timeframe_prompt": " Invalid timeframe. Use: 1d, 1w, 1m, or 3m",
    "invalid_symbol_prompt": " Invalid cryptocurrency symbol",
    "analysis_prompt": " Analyze {coin_id} for {timeframe} period:\n{analysis}",
    "news_analysis_prompt": " Analyze recent news for {query}:\n{news}",
    "indicator_explanation_prompt": " Explain the {indicator} technical indicator in crypto context",
    "query_parse_error": " I couldn't understand your request. Try phrases like:\n- 'Analyze BTC price'\n- 'Latest news about ETH'",
    "query_error": " Error processing query: {error}",
    "no_news_found": " No news found for {symbol}",
    "analysis_error": " Analysis error: {error}",

    "date_label": " Date",
    "price_label": " Price",
    "volume_label": " Volume",
    "price_chart_title": " Price Movement",
    "ma_chart_title": " Moving Averages Analysis",
    "macd_chart_title": " MACD Indicator",
    "rsi_chart_title": " RSI Analysis",
    "volume_chart_title": " Volume Analysis",
    "ma20_label": "20-Day MA",
    "ma50_label": "50-Day MA",
    "ma200_label": "200-Day MA",
    "macd_line": "MACD Line",
    "signal_line": "Signal Line",
    "histogram": "Histogram",
    "open_price": " Open",
    "high_price": " High",
    "low_price": " Low",
    "close_price": " Close",

    "analysis_button": " Analysis",
    "charts_button": " Charts",
    "help_button": " Help",
    "settings_button": " Settings",
    "quick_analysis_button": " Quick Analysis",
    "full_analysis_button": " Full Analysis",
    "custom_charts_button": " Custom Charts",
    "back_button": " Back",
    "language_button": " Switch Language",
    "timeframe_button": " Default Timeframe",
    "chart_type_button": " Default Chart Type",

    "generating_chart_progress": " Generating Chart: [{}] {}%",
    "chart_complete": " Chart generation complete",
    "error_generating_chart": " Error generating chart",
    "provide_symbol_and_chart": " Please provide symbol and chart type",
    "chart_example": " Example: /chart btc price",

    "admin_menu": " Admin Control Panel",
    "select_tracking_option": " Select a tracking option to view user statistics:",
    "select_user_management_option": " Select a user management option:",
    "select_admin_management_option": " Select an admin management option:",

    "users_tracking": " User Statistics",
    "manage_users": " Manage Users",
    "manage_admins": " Manage Admins",

    "most_searched_stats": " Most Searched Symbols Statistics:",
    "popular_analysis_stats": " Popular Analysis Types Statistics:",
    "most_searched": " Most Searched Symbols",
    "popular_analysis": " Popular Analysis Types",

    "users_list": " List of Registered Users:",
    "provide_user_id_for_subscription": " Enter the user ID to change subscription status:",
    "provide_user_id_for_ban": " Enter the user ID to ban user:",
    "list_users": " View All Users",
    "change_subscription": " Change Subscription",
    "ban_user": " Ban User",

    "provide_new_admin_id": " Enter the user ID to promote to admin:",
    "provide_admin_id_for_role_change": " Enter the admin ID to change role:",
    "provide_admin_id_for_removal": " Enter the admin ID to remove admin status:",
    "add_new_admin": " Add New Admin",
    "change_admin_role": " Change Admin Role",
    "remove_admin": " Remove Admin",

    "error_invalid_id": " Invalid user ID provided",
    "error_no_permission": " You don't have permission to perform this action",
    "error_user_not_found": " User not found",

    "success_subscription_changed": " User subscription status updated successfully",
    "success_user_banned": " User has been banned successfully",
    "success_admin_added": " New admin has been added successfully",
    "success_admin_removed": " Admin has been removed successfully",
    "success_role_changed": " Admin role has been updated successfully",

    "somthing_went_wrong": " Something went wrong",
    "do_you_want_to_change_it": " Do you want to change it?",
    "subscription_was_changed": " Subscription was changed",
    "proceed_with_banning_user": " Proceed with banning user: ",
    "invalid_chart_type": " Invalid chart type",
    "quick_analysis": " Quick Analysis",
    "provide_symbol_news": " Provide a symbol to fetch news",
    "user_current_subscription": " User current subscription is",
    "new_admin": " Add New Admin",
    "change_role": " Change Admin Role",
    "delete_admin": " Delete Admin",
    "guest": " Guest Subscription",
    "premium": " Premium Subscription",
    "master": " Master Role",
    "normal": " Normal Role",
    "watcher": " Watcher Role",
    "yes": " Yes",
    "not_authorized": "sorry you do not authorized to do this operation.",
   
     


  
  "education_button": " Education",

  "news_analysis_button": " News Analysis",
   "help_intro_button": " Introduction",
    "help_commands_button": " Commands",
    "help_navigation_button": " Navigation",
    "help_analysis_button": " Analysis",
    "help_charts_button": " Charts",
    "help_news_button": " News",
    "help_agent_button": " AI Agent",
    "help_troubleshooting_button": " Troubleshooting",
    "help_settings_button": " Settings",
    "help_feedback_button": " Feedback",
    "help_menu": "Help Menu",
    "help_intro_text":" Welcome to the CryptoAnalyst Bot! I am here to help you with Cryptocurrency Analysis and charts. \n\nSelect a button below to explore more about the bot!",
    "help_commands_text":"Here are the commands available:\n\n/start: starts the bot and shows the main menu \n/analyze [symbol] [timeframe (optional)]: does full technical analysis.\n/quick [symbol]: Gives quick market overview.\n/chart [symbol] [type] [timeframe (optional)]: Generates a custom chart.\n/news [symbol]: Gives latest news about crypto coin.",
    "help_navigation_text":"The bot uses inline keyboards for navigation. \n\nUse the main menu to access the different features.\nSelect one of the options from any menu to proceed to the next step. \nUse the back button to return to the main menu or the previous menu.",
      "help_analysis_text":"The bot provides different analysis options.\n\nQuick Analysis: use /quick command or select Quick Analysis from the menu to get basic technical analysis.\nFull Analysis: use /analyze command or select Full Analysis from the menu to get detailed technical analysis.\nCustom Chart: use /chart command or select custom chart from the menu to get charts with specific type and timeframe. ",
    "help_charts_text":"The bot supports different types of charts: \n\nPrice chart: Shows the price movements\nMoving Averages chart: Shows the moving averages for a specific coin\nMACD chart: Shows MACD for a specific coin\nRSI chart: Shows RSI for a specific coin\nVolume chart: Shows volume for a specific coin",
     "help_news_text":"The bot provides latest news for a specific coin.\n\nUse /news command or select news analysis from the menu to get the latest news about a crypto coin. \nThe bot summarizes the news and shows the sentiment for each article.",
        "help_agent_text":"The bot also uses an AI agent. \n\nEnter any text and let the agent handle your request for you.\n\nExamples: \n - Analyze BTC price \n- Explain RSI\n- What is the current price of Ethereum?",
    "help_troubleshooting_text":"Here are some common issues and how to resolve them:\n\nInvalid Symbol: Make sure that the symbol that you are using is a valid symbol\nInvalid Timeframe: Make sure to select valid timeframe from the options: 1d, 1w, 1m, or 3m.\nError in analysis: Please make sure that you are using the correct command and symbol.",
    "help_settings_text":"Here are the settings available for the bot:\n\nLanguage: Switch the language between English and Arabic.\nDefault Timeframe: Change the default time frame used by the bot.\nDefault Chart Type: Select the default chart type.",
   "help_feedback_text":"We are always trying to improve the bot, if you have any feature requests or bug report please contact the developers.",
    "education_menu": " Education Menu",
     "education_basic_concepts": " Basic Concepts",
    "education_technical_analysis": " Technical Analysis",
    "education_trading_strategies":" Trading Strategies",
    "education_defi_nfts": " DeFi & NFTs",
     "education_security": " Security",
   "education_topic_basic_concepts_introduction_title": "Introduction to Blockchain",
   "education_topic_basic_concepts_introduction_text": "A blockchain is a shared, immutable ledger that facilitates the process of recording transactions and tracking assets in a business network.",
     "education_topic_basic_concepts_introduction_link_1_text": "Learn more about Blockchain",
  "education_topic_basic_concepts_introduction_link_1_url": "https://www.ibm.com/topics/blockchain",
   "education_topic_basic_concepts_cryptocurrencies_title": "Understanding Cryptocurrencies",
   "education_topic_basic_concepts_cryptocurrencies_text": "A cryptocurrency is a digital or virtual currency secured by cryptography, which makes it nearly impossible to counterfeit or double-spend. Many cryptocurrencies are decentralized networks based on blockchain technology.",
      "education_topic_basic_concepts_cryptocurrencies_link_1_text": "Learn more about Cryptocurrencies",
  "education_topic_basic_concepts_cryptocurrencies_link_1_url": "https://www.investopedia.com/terms/c/cryptocurrency.asp",
   "education_topic_basic_concepts_wallets_title": "Understanding Crypto Wallets",
    "education_topic_basic_concepts_wallets_text": "A cryptocurrency wallet is a device, physical medium, program or a service which stores the public and/or private keys for cryptocurrency transactions.",
       "education_topic_basic_concepts_wallets_link_1_text": "Learn more about Crypto Wallets",
  "education_topic_basic_concepts_wallets_link_1_url": "https://www.investopedia.com/terms/c/cryptocurrency-wallet.asp",
    "education_topic_basic_concepts_exchanges_title": "Understanding Crypto Exchanges",
    "education_topic_basic_concepts_exchanges_text": "A cryptocurrency exchange, or a digital currency exchange, is a business that allows customers to trade cryptocurrencies or digital currencies for other assets, such as conventional fiat money or other digital currencies.",
       "education_topic_basic_concepts_exchanges_link_1_text": "Learn more about Crypto Exchanges",
      "education_topic_basic_concepts_exchanges_link_1_url": "https://www.investopedia.com/terms/c/cryptocurrencyexchange.asp",
    "education_topic_technical_analysis_moving_averages_title": "Moving Averages (MA)",
    "education_topic_technical_analysis_moving_averages_text": "Moving averages smooth out price data to make it easier to identify the trend. There are different types of MA such as the SMA, EMA, etc",
    "education_topic_technical_analysis_rsi_indicator_title":"Relative Strength Index (RSI)",
    "education_topic_technical_analysis_rsi_indicator_text":"The Relative Strength Index (RSI) is a momentum indicator that measures the magnitude of recent price changes to evaluate overbought or oversold conditions in the price of a stock or other asset.",
     "education_topic_technical_analysis_rsi_indicator_link_1_text": "Learn more about RSI",
     "education_topic_technical_analysis_rsi_indicator_link_1_url": "https://www.investopedia.com/terms/r/rsi.asp",
    "education_topic_technical_analysis_macd_indicator_title":"Moving Average Convergence Divergence (MACD)",
    "education_topic_technical_analysis_macd_indicator_text":"The Moving Average Convergence Divergence (MACD) is a trend-following momentum indicator that shows the relationship between two moving averages of a securitys price.",
     "education_topic_technical_analysis_macd_indicator_link_1_text": "Learn more about MACD",
     "education_topic_technical_analysis_macd_indicator_link_1_url":"https://www.investopedia.com/terms/m/macd.asp",
    "education_topic_technical_analysis_bollinger_bands_title":"Bollinger Bands",
    "education_topic_technical_analysis_bollinger_bands_text":"Bollinger Bands are volatility bands placed above and below a moving average. Volatility is based on standard deviation, which changes as volatility increases and decreases. ",
    "education_topic_technical_analysis_support_resistance_title":"Support and Resistance",
    "education_topic_technical_analysis_support_resistance_text": "Support and resistance levels are key areas where price movements are expected to slow or reverse. Support refers to the price level where buying pressure is expected to prevent a price decline, while resistance refers to the price level where selling pressure is expected to prevent a price increase.",
    "education_topic_trading_strategies_day_trading_title": "Day Trading",
    "education_topic_trading_strategies_day_trading_text":"Day trading is a type of trading in which you buy and sell positions within the same day to profit from small price movements.",
    "education_topic_trading_strategies_swing_trading_title":"Swing Trading",
    "education_topic_trading_strategies_swing_trading_text":"Swing trading is a strategy that involves holding assets for a few days or weeks to capture profits from expected price swings.",
    "education_topic_defi_nfts_what_is_defi_title":"What is DeFi?",
     "education_topic_defi_nfts_what_is_defi_text":"DeFi, or Decentralized Finance, uses blockchain technology to offer financial services without centralized intermediaries like banks and financial institutions.",
    "education_topic_defi_nfts_what_is_nft_title":"What are NFTs?",
     "education_topic_defi_nfts_what_is_nft_text":"A non-fungible token (NFT) is a unique digital asset representing a wide range of tangible and intangible items, such as artworks, collectibles, and in-game items.",
    "education_topic_security_scams_title":"Common Crypto Scams",
    "education_topic_security_scams_text":"There are many crypto scams such as phishing, ponzi schemes and pump and dumps. Always do your own research before you invest.",
    "back_education": " Back to Education"
}
</file>

<file path="llm\agent.py">
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain.agents import initialize_agent, Tool
from langchain_core.tools import tool
from langchain.agents import AgentType
from langchain.schema import HumanMessage, SystemMessage
from typing import Dict, Optional
from dotenv import load_dotenv
import sys
import os
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..')))
from src.analysis.technical import TechnicalAnalyzer
from src.utils.formatters import TelegramFormatter
from src.utils.news_formatters import NewsFormatter
from src.data.processor import DataProcessor
from src.data.cc_news import CryptoNewsFetcher

class CryptoAnalysisAgent:
    def __init__(self, google_api_key: str = None):
        """
        Initialize the Crypto Analysis Agent.
        
        Args:
            google_api_key (str, optional): Google API key. If not provided, will try to get from environment.
        """
        self.analyzer = TechnicalAnalyzer()
        self.formatter = TelegramFormatter()
        self.data_processor = DataProcessor()
        self.news_fetcher = CryptoNewsFetcher(os.getenv("CRYPTO_NEWS_TOKEN"))
        self.news_formatter = NewsFormatter()

        self.timeframes = {
            '1d': 1,
            '1w': 7,
            '1m': 30,
            '3m': 90
        }
        # Load API key
        if google_api_key:
            self.api_key = google_api_key
        else:
            load_dotenv()
            self.api_key = os.getenv("GOOGLE_API_KEY")
            
        if not self.api_key:
            raise ValueError("Google API key is required. Either pass it to the constructor or set GOOGLE_API_KEY environment variable.")

        # Initialize Gemini model
        try:
            self.llm = ChatGoogleGenerativeAI(model="gemini-1.5-flash", google_api_key=self.api_key)
            print("Using Gemini 1.5")
        except Exception as e:
            print(f"Gemini 1.5 not available: {e}")
            self.llm = ChatGoogleGenerativeAI(model="gemini-pro", google_api_key=self.api_key)
            print("Falling back to Gemini Pro")

        # Initialize tools
        self.tools = [
            Tool(
                name="QuickAnalysis",
                func=self._quick_analysis,
                description="Useful for technical analysis of cryptocurrencies. Input should include coin symbol as first parameter and timeframe as second parameter (options: 1d, 1w, 1m, 3m). the Input should be (coin_symbol timeframe)"
            ),
            Tool(
                name="NewsAnalysis",
                func=self._news_analysis,
                description="Useful for analyzing news and sentiment about cryptocurrencies. Input should include coin symbol."
            ),
            Tool(
              name="ExplainIndicator",
              func=self._explain_indicator,
              description="Learn about a technical indicator. Input the indicator name."
            )
        ]
        
        # Initialize the agent
        self.agent = initialize_agent(
            self.tools,
            self.llm,
            agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION,
            verbose=True
        )

    def _quick_analysis(self, query: str) -> str:
        '''Perform a quick analysis of a cryptocurrency based on the given timeframe.'''
        coin_id, timeframe = query.split(" ", 1)
        print(f"coin_id: {coin_id}, timeframe: {timeframe}")
        if timeframe not in self.timeframes:
           return self.formatter._t('invalid_timeframe_prompt')

        try:
            # Validate coin
            if not self.data_processor.validate_coin_id(coin_id):
               return f" {self.formatter._t('invalid_symbol_prompt')}: {coin_id}"

            # Get analysis
            days = self.timeframes[timeframe]
            analysis = self.analyzer.analyze_coin(coin_id, days=days)
            
            # Send text analysis
            # formatted_message = self.formatter.format_full_analysis(analysis, coin_id)
            print(f"formatted_message: {analysis}")
            # This is a placeholder - implement your actual analysis here
            analysis_prompt = self.formatter._t('analysis_prompt').format(
               coin_id=coin_id,
               timeframe=timeframe,
               analysis=analysis
            ) 
            response = self.llm.invoke([HumanMessage(content=analysis_prompt)])
            return response.content

        except Exception as e:
            print(str(e))
            return(self.formatter._t('analysis_error').format(error=str(e)))
        
    

    def _news_analysis(self, query: str) -> str:
        # Get news articles
        news_df, success = self.news_fetcher.get_news_by_coin(
            categories=query,
            limit=10,
            lang="EN"
        )
        
        if not success or news_df.empty:
            formatted_message= self.formatter._t('no_news_found').format(symbol=query)
        # Get formatted message
        formatted_message = self.news_formatter.format_news(news_df, query)
        # This is a placeholder - implement your actual analysis here
        news_prompt = self.formatter._t('news_analysis_prompt').format(
           query=query,
           news=formatted_message)
        response = self.llm.invoke([HumanMessage(content=news_prompt)])
        return response.content
    
    def _explain_indicator(self, query: str) -> str:
        """
        Explain a technical indicator based on user input.

        Args:
            query (str): Name of the technical indicator.

        Returns:
            str: Explanation of the indicator retrieved from the LLM.
        """
        indicator_name = query.strip()

        # If no external source, use a generic prompt
        indicator_prompt = self.formatter._t('indicator_explanation_prompt').format(
           indicator=indicator_name
       )
        response = self.llm.invoke([HumanMessage(content=indicator_prompt)])
        return response.content

    def process_query(self, text: str) -> str:
        """
        Process a user query and return the response.
        
        Args:
            text (str): The user's query text
            
        Returns:
            str: The processed response
            
        Raises:
            ValueError: If the query couldn't be processed
            Exception: For other unexpected errors
        """
        try:
            result = self.agent.invoke(text)
            return result
        except ValueError as e:
            if "Could not parse LLM output" in str(e):
                return {
                   'output': self.formatter._t('query_parse_error')
               }
            raise e
        except Exception as e:
           raise Exception(self.formatter._t('query_error').format(error=str(e)))

def main():
    """Example usage of the CryptoAnalysisAgent"""
    
    # Initialize the agent
    agent = CryptoAnalysisAgent()
    
    # Interactive loop
    print("Crypto Analysis Agent (type 'exit' to quit)")
    print("Example queries:")
    print("- Analyze BTC price for the next hour")
    print("- What's the latest news about ETH?")
    print("- Can you explain what RSI means?")
    
    while True:
        user_input = input("\nEnter your query: ")
        if user_input.lower() == 'exit':
            break
            
        try:
            result = agent.process_query(user_input)
            print(f"\nResponse: {result}")
        except Exception as e:
            print(f"\nError: {str(e)}")

if __name__ == "__main__":
    main()
</file>

<file path="services\cache_manager.py">
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.sql import select
from datetime import datetime, timedelta
import pandas as pd
import logging
from typing import Optional, Dict, List
from .models import Base, CryptoOHLCV, TimeInterval, CoinMetadata

class CacheManager:
    def __init__(self, database_url: str, cache_duration: Dict[str, int] = None):
        """
        Initialize the cache manager.
        
        Args:
            database_url: SQLAlchemy database URL
            cache_duration: Dict of cache durations in seconds for different intervals
                          e.g., {'1': 300, '7': 600, '30': 1800, '90': 3600}
        """
        self.engine = create_engine(database_url)
        Base.metadata.create_all(self.engine)
        self.Session = sessionmaker(bind=self.engine)
        
        # Default cache durations for different intervals (in seconds)
        self.cache_duration = cache_duration or {
             1: 300,    # 5 minutes for 1-day data
             7: 600,    # 10 minutes for 7-day data
             30: 1800,  # 30 minutes for 30-day data
             90: 3600   # 1 hour for 90-day data
        }
        self.logger = logging.getLogger(__name__)

    def get_ohlcv_data(
        self, 
        coin_id: str, 
        vs_currency: str,
        interval: str,
        start_time: datetime,
        end_time: datetime
    ) -> Optional[pd.DataFrame]:
        """
        Get OHLCV data from cache if available and not expired.
        
        Args:
            coin_id: Cryptocurrency identifier
            vs_currency: Quote currency (e.g., 'usd')
            interval: Time interval ('1', '7', '30', '90')
            start_time: Start time for data range
            end_time: End time for data range
        """
        session = self.Session()
        try:
            # Get cache duration for this interval
            cache_duration = self.cache_duration.get(interval, 300)
            cache_threshold = datetime.utcnow() - timedelta(seconds=cache_duration)
            
            query = (
                select(CryptoOHLCV)
                .where(
                    CryptoOHLCV.coin_id == coin_id,
                    CryptoOHLCV.vs_currency == vs_currency,
                    CryptoOHLCV.interval == TimeInterval(interval),
                    CryptoOHLCV.timestamp.between(start_time, end_time),
                    CryptoOHLCV.last_updated > cache_threshold
                )
                .order_by(CryptoOHLCV.timestamp)
            )
            
            result = session.execute(query).fetchall()
            
            if result:
                # Convert to DataFrame
                df = pd.DataFrame([{
                    'timestamp': row.CryptoOHLCV.timestamp,
                    'open': row.CryptoOHLCV.open,
                    'high': row.CryptoOHLCV.high,
                    'low': row.CryptoOHLCV.low,
                    'close': row.CryptoOHLCV.close,
                    'volume': row.CryptoOHLCV.volume,
                    'market_cap': row.CryptoOHLCV.market_cap
                } for row in result])
                
                df.set_index('timestamp', inplace=True)
                return df
                
            return None
            
        except Exception as e:
            self.logger.error(f"Error fetching from cache: {str(e)}")
            return None
        finally:
            session.close()

    def update_ohlcv_data(
        self,
        coin_id: str,
        vs_currency: str,
        interval: str,
        df: pd.DataFrame
    ):
        """
        Update OHLCV data in the cache.
        
        Args:
            coin_id: Cryptocurrency identifier
            vs_currency: Quote currency (e.g., 'usd')
            interval: Time interval ('1', '7', '30', '90')
            df: DataFrame containing OHLCV data
        """
        session = self.Session()
        try:
            # Delete existing data for the same period and interval
            start_time = df.index.min()
            end_time = df.index.max()
            
            session.query(CryptoOHLCV).filter(
                CryptoOHLCV.coin_id == coin_id,
                CryptoOHLCV.vs_currency == vs_currency,
                CryptoOHLCV.interval == TimeInterval(interval),
                CryptoOHLCV.timestamp.between(start_time, end_time)
            ).delete()

            # Insert new data
            for timestamp, row in df.iterrows():
                entry = CryptoOHLCV(
                    coin_id=coin_id,
                    vs_currency=vs_currency,
                    interval=TimeInterval(interval),
                    timestamp=timestamp,
                    open=row['open'],
                    high=row['high'],
                    low=row['low'],
                    close=row['close'],
                    volume=row['volume'],
                    market_cap=row['market_cap'],
                    last_updated=datetime.utcnow()
                )
                session.add(entry)
            
            session.commit()
            
        except Exception as e:
            session.rollback()
            self.logger.error(f"Error updating cache: {str(e)}")
            raise
        finally:
            session.close()
    
    def update_coin_metadata(self, coin_data: Dict):
        """
        Update coin metadata in the cache.
        """
        session = self.Session()
        try:
            existing = session.query(CoinMetadata).filter_by(
                coin_id=coin_data['id']
            ).first()
            
            if existing:
                existing.symbol = coin_data.get('symbol')
                existing.name = coin_data.get('name')
                existing.extra_data = coin_data
                existing.last_updated = datetime.utcnow()
            else:
                entry = CoinMetadata(
                    coin_id=coin_data['id'],
                    symbol=coin_data.get('symbol'),
                    name=coin_data.get('name'),
                    extra_data=coin_data,
                    last_updated=datetime.utcnow()
                )
                session.add(entry)
            
            session.commit()
            
        except Exception as e:
            session.rollback()
            self.logger.error(f"Error updating coin metadata: {str(e)}")
            raise
        finally:
            session.close()

    def get_coin_metadata(self, coin_id: str) -> Optional[Dict]:
        """
        Get coin metadata from cache if available and not expired.
        """
        session = self.Session()
        try:
            cache_threshold = datetime.utcnow() - timedelta(seconds=self.cache_duration[30])
            
            result = session.query(CoinMetadata).filter(
                CoinMetadata.coin_id == coin_id,
                CoinMetadata.last_updated > cache_threshold
            ).first()
            
            if result:
                return {
                    'id': result.coin_id,
                    'symbol': result.symbol,
                    'name': result.name,
                    'extra_data': result.extra_data
                }
            
            return None
            
        except Exception as e:
            self.logger.error(f"Error fetching coin metadata: {str(e)}")
            return None
        finally:
            session.close()

    def get_coin_id_by_symbol(self, symbol: str) -> Optional[str]:
        """
        Get coin ID from database using symbol.
        Returns None if symbol not found.
        """
        session = self.Session()
        try:
            result = session.query(CoinMetadata)\
                .filter(CoinMetadata.symbol.ilike(symbol))\
                .first()

            return result.coin_id if result else None

        except Exception as e:
            self.logger.error(f"Error searching symbol {symbol}: {str(e)}")
            return None
        finally:
            session.close()

    def update_coins_list(self, coins: List[Dict]):
        """Update all coins metadata in cache."""
        session = self.Session()
        try:
            for coin in coins:
                existing = session.query(CoinMetadata).filter_by(coin_id=coin['id']).first()
                
                if existing:
                    existing.symbol = coin.get('symbol')
                    existing.name = coin.get('name')
                    existing.extra_data = coin
                    existing.last_updated = datetime.utcnow()
                else:
                    entry = CoinMetadata(
                        coin_id=coin['id'],
                        symbol=coin.get('symbol'),
                        name=coin.get('name'),
                        extra_data=coin,
                        last_updated=datetime.utcnow()
                    )
                    session.add(entry)
            
            session.commit()
        except Exception as e:
            session.rollback()
            self.logger.error(f"Error updating coins list: {str(e)}")
            raise
        finally:
            session.close()

    def get_all_coins(self) -> List[Dict]:
        """Get all coins from cache."""
        session = self.Session()
        try:
            coins = session.query(CoinMetadata).all()
            return [{
                'id': coin.coin_id,
                'symbol': coin.symbol,
                'name': coin.name,
                **coin.extra_data
            } for coin in coins]
        finally:
            session.close()
</file>

<file path="services\coingecko_api.py">
API_KEY = 'CG-QbiHEtuJRDvmqSGpAiFZcCby'

import requests

class CoinGeckoAPI:
    def __init__(self):
        self.base_url = "https://api.coingecko.com/api/v3"
        self.headers = {
            "accept": "application/json",
            "x-cg-demo-api-key": API_KEY,
        }

    def ping(self):
        endpoint = f"{self.base_url}/ping"
        response = requests.get(endpoint, headers=self.headers)

        # Check for request success and return JSON, or raise error.
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()

    def get_simple_price(self, ids, vs_currencies, include_market_cap=False, include_24hr_vol=False, 
                     include_24hr_change=False, include_last_updated_at=False, precision=None, api_key=API_KEY):
  
        # Makes a GET request to the /simple/price endpoint.

        # Args:
        #     ids (str): Coins' IDs, comma-separated.
        #     vs_currencies (str): Target currency, comma-separated.
        #     include_market_cap (bool, optional): Include market cap. Default is False.
        #     include_24hr_vol (bool, optional): Include 24hr volume. Default is False.
        #     include_24hr_change (bool, optional): Include 24hr change. Default is False.
        #     include_last_updated_at (bool, optional): Include last updated time. Default is False.
        #     precision (str, optional): Decimal places for currency price value.
        #     api_key (str, optional): API key for authorization.

        # Returns:
        #     dict: The JSON response from the API.
    
        endpoint = f"{self.base_url}/simple/price"
        headers = self.headers.copy()
        if api_key:
            headers["x-cg-demo-api-key"] = api_key
        
        params = {
            "ids": ids,
            "vs_currencies": vs_currencies,
            "include_market_cap": str(include_market_cap).lower(),
            "include_24hr_vol": str(include_24hr_vol).lower(),
            "include_24hr_change": str(include_24hr_change).lower(),
            "include_last_updated_at": str(include_last_updated_at).lower(),
            "precision": precision
        }
        
        response = requests.get(endpoint, headers=headers, params=params)
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()

    def get_token_price(self, id, contract_addresses, vs_currencies, include_market_cap=False, 
                        include_24hr_vol=False, include_24hr_change=False, include_last_updated_at=False, precision=None, api_key=API_KEY):
        endpoint = f"{self.base_url}/simple/token_price/{id}"
        headers = self.headers.copy()
        if api_key:
            headers["x-cg-demo-api-key"] = api_key
        params = {
            "contract_addresses": contract_addresses,
            "vs_currencies": vs_currencies,
            "include_market_cap": str(include_market_cap).lower(),
            "include_24hr_vol": str(include_24hr_vol).lower(),
            "include_24hr_change": str(include_24hr_change).lower(),
            "include_last_updated_at": str(include_last_updated_at).lower(),
            "precision": precision
        }
        response = requests.get(endpoint, headers=headers, params=params)
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()


    def get_supported_vs_currencies(self, api_key=API_KEY):
        endpoint = f"{self.base_url}/simple/supported_vs_currencies"
        headers = self.headers.copy()
        if api_key:
            headers["x-cg-demo-api-key"] = api_key
        response = requests.get(endpoint, headers=headers)
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()


    def get_coins_list(self, include_platform=False, api_key=API_KEY):
        endpoint = f"{self.base_url}/coins/list"
        headers = self.headers.copy()
        if api_key:
            headers["x-cg-demo-api-key"] = api_key
        params = {
            "include_platform": str(include_platform).lower()
        }
        response = requests.get(endpoint, headers=headers, params=params)
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()
        
    def get_coins_markets(self, vs_currency, ids=None, category=None, order="market_cap_desc", per_page=100, 
                        page=1, sparkline=False, price_change_percentage=None, locale="en", precision=None, api_key=API_KEY):
        endpoint = f"{self.base_url}/coins/markets"
        headers = self.headers.copy()
        if api_key:
            headers["x-cg-demo-api-key"] = api_key
        params = {
            "vs_currency": vs_currency,
            "ids": ids,
            "category": category,
            "order": order,
            "per_page": per_page,
            "page": page,
            "sparkline": str(sparkline).lower(),
            "price_change_percentage": price_change_percentage,
            "locale": locale,
            "precision": precision
        }
        response = requests.get(endpoint, headers=headers, params=params)
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()


    def get_coin_details(self, id, localization=True, tickers=True, market_data=True, community_data=True, 
                        developer_data=True, sparkline=False, api_key=API_KEY):
        endpoint = f"{self.base_url}/coins/{id}"
        headers = self.headers.copy()
        if api_key:
            headers["x-cg-demo-api-key"] = api_key
        params = {
            "localization": str(localization).lower(),
            "tickers": str(tickers).lower(),
            "market_data": str(market_data).lower(),
            "community_data": str(community_data).lower(),
            "developer_data": str(developer_data).lower(),
            "sparkline": str(sparkline).lower()
        }
        response = requests.get(endpoint, headers=headers, params=params)
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()


    def get_coin_tickers(self, id, exchange_ids=None, include_exchange_logo=False, page=1, order="trust_score_desc", 
                        depth=False, api_key=API_KEY):
        endpoint = f"{self.base_url}/coins/{id}/tickers"
        headers = self.headers.copy()
        if api_key:
            headers["x-cg-demo-api-key"] = api_key
        params = {
            "exchange_ids": exchange_ids,
            "include_exchange_logo": str(include_exchange_logo).lower(),
            "page": page,
            "order": order,
            "depth": str(depth).lower()
        }
        response = requests.get(endpoint, headers=headers, params=params)
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()


    def get_coin_history(self, id, date, localization=True, api_key=API_KEY):
        endpoint = f"{self.base_url}/coins/{id}/history"
        headers = self.headers.copy()
        if api_key:
            headers["x-cg-demo-api-key"] = api_key
        params = {
            "date": date,
            "localization": str(localization).lower()
        }
        response = requests.get(endpoint, headers=headers, params=params)
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()


    def get_coin_market_chart(self, id, vs_currency, days, interval=None, precision=None, api_key=API_KEY):
        endpoint = f"{self.base_url}/coins/{id}/market_chart"
        headers = self.headers.copy()
        if api_key:
            headers["x-cg-demo-api-key"] = api_key
        params = {
            "vs_currency": vs_currency,
            "days": days,
            "interval": interval,
            "precision": precision
        }
        response = requests.get(endpoint, headers=headers, params=params)
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()


    def get_coin_ohlc(self, id, vs_currency, days, precision=None, api_key=API_KEY):
        endpoint = f"{self.base_url}/coins/{id}/ohlc"
        headers = self.headers.copy()
        if api_key:
            headers["x-cg-demo-api-key"] = api_key
        params = {
            "vs_currency": vs_currency,
            "days": days,
            "precision": precision
        }
        response = requests.get(endpoint, headers=headers, params=params)
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()

    def get_asset_platforms(self, filter=None, api_key=API_KEY):
        endpoint = f"{self.base_url}/asset_platforms"
        headers = self.headers.copy()
        if api_key:
            headers["x-cg-demo-api-key"] = api_key
        params = {
            "filter": filter
        }
        response = requests.get(endpoint, headers=headers, params=params)
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()


    def get_categories_list(self, api_key=API_KEY):
        endpoint = f"{self.base_url}/coins/categories/list"
        headers = self.headers.copy()
        if api_key:
            headers["x-cg-demo-api-key"] = api_key
        response = requests.get(endpoint, headers=headers)
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()


    def get_categories(self, order="market_cap_desc", api_key=API_KEY):
        endpoint = f"{self.base_url}/coins/categories"
        headers = self.headers.copy()
        if api_key:
            headers["x-cg-demo-api-key"] = api_key
        params = {
            "order": order
        }
        response = requests.get(endpoint, headers=headers, params=params)
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()


    def get_exchanges(self, per_page=100, page=1, api_key=API_KEY):
        endpoint = f"{self.base_url}/exchanges"
        headers = self.headers.copy()
        if api_key:
            headers["x-cg-demo-api-key"] = api_key
        params = {
            "per_page": per_page,
            "page": page
        }
        response = requests.get(endpoint, headers=headers, params=params)
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()


    def get_exchange_details(self, id, api_key=API_KEY):
        endpoint = f"{self.base_url}/exchanges/{id}"
        headers = self.headers.copy()
        if api_key:
            headers["x-cg-demo-api-key"] = api_key
        response = requests.get(endpoint, headers=headers)
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()


    def get_exchange_tickers(self, id, coin_ids=None, include_exchange_logo=False, page=1, depth=False, order="trust_score_desc", api_key=API_KEY):
        endpoint = f"{self.base_url}/exchanges/{id}/tickers"
        headers = self.headers.copy()
        if api_key:
            headers["x-cg-demo-api-key"] = api_key
        params = {
            "coin_ids": coin_ids,
            "include_exchange_logo": str(include_exchange_logo).lower(),
            "page": page,
            "depth": str(depth).lower(),
            "order": order
        }
        response = requests.get(endpoint, headers=headers, params=params)
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()


    def get_global(self, api_key=API_KEY):
        endpoint = f"{self.base_url}/global"
        headers = self.headers.copy()
        if api_key:
            headers["x-cg-demo-api-key"] = api_key
        response = requests.get(endpoint, headers=headers)
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()


    def get_global_defi(self, api_key=API_KEY):
        endpoint = f"{self.base_url}/global/decentralized_finance_defi"
        headers = self.headers.copy()
        if api_key:
            headers["x-cg-demo-api-key"] = api_key
        response = requests.get(endpoint, headers=headers)
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()


    def get_exchange_volume_chart(self, id, days, api_key=API_KEY):
        endpoint = f"{self.base_url}/exchanges/{id}/volume_chart"
        headers = self.headers.copy()
        if api_key:
            headers["x-cg-demo-api-key"] = api_key
        params = {
            "days": days
        }
        response = requests.get(endpoint, headers=headers, params=params)
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()


    def get_derivatives(self, api_key=API_KEY):
        endpoint = f"{self.base_url}/derivatives"
        headers = self.headers.copy()
        if api_key:
            headers["x-cg-demo-api-key"] = api_key
        response = requests.get(endpoint, headers=headers)
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()


    def get_derivative_exchanges(self, order="open_interest_btc_desc", per_page=100, page=1, api_key=API_KEY):
        endpoint = f"{self.base_url}/derivatives/exchanges"
        headers = self.headers.copy()
        if api_key:
            headers["x-cg-demo-api-key"] = api_key
        params = {
            "order": order,
            "per_page": per_page,
            "page": page
        }
        response = requests.get(endpoint, headers=headers, params=params)
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()


    def get_derivative_exchange_details(self, id, include_tickers=None, api_key=API_KEY):
        endpoint = f"{self.base_url}/derivatives/exchanges/{id}"
        headers = self.headers.copy()
        if api_key:
            headers["x-cg-demo-api-key"] = api_key
        params = {
            "include_tickers": include_tickers
        }
        response = requests.get(endpoint, headers=headers, params=params)
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()


    def get_derivative_exchanges_list(self, api_key=API_KEY):
        endpoint = f"{self.base_url}/derivatives/exchanges/list"
        headers = self.headers.copy()
        if api_key:
            headers["x-cg-demo-api-key"] = api_key
        response = requests.get(endpoint, headers=headers)
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()


    def get_exchange_rates(self, api_key=API_KEY):
        endpoint = f"{self.base_url}/exchange_rates"
        headers = self.headers.copy()
        if api_key:
            headers["x-cg-demo-api-key"] = api_key
        response = requests.get(endpoint, headers=headers)
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()


    def search(self, query, api_key=API_KEY):
        endpoint = f"{self.base_url}/search"
        headers = self.headers.copy()
        if api_key:
            headers["x-cg-demo-api-key"] = api_key
        params = {
            "query": query
        }
        response = requests.get(endpoint, headers=headers, params=params)
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()


    def get_trending(self, api_key=API_KEY):
        endpoint = f"{self.base_url}/search/trending"
        headers = self.headers.copy()
        if api_key:
            headers["x-cg-demo-api-key"] = api_key
        response = requests.get(endpoint, headers=headers)
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()


# Usage Example
if __name__ == "__main__":


    api = CoinGeckoAPI()
    result = api.get_trending()
    print(result)
</file>

<file path="services\database.py">
from sqlalchemy import Boolean, create_engine, Column, Integer, String, Float, JSON, DateTime, ForeignKey, UniqueConstraint, Enum
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship, sessionmaker
from datetime import datetime
import enum

# Create base class for declarative models
Base = declarative_base()

class Coin(Base):
    """Model for storing basic cryptocurrency information."""
    __tablename__ = 'coins'

    id = Column(String, primary_key=True)  # e.g., "bitcoin"
    symbol = Column(String, nullable=False)  # e.g., "btc"
    name = Column(String, nullable=False)  # e.g., "Bitcoin"
    platforms = Column(JSON)
    last_updated = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # Relationships
    prices = relationship("CoinPrice", back_populates="coin", cascade="all, delete-orphan")
    ohlc_data = relationship("OHLC", back_populates="coin", cascade="all, delete-orphan")
    trending_data = relationship("TrendingCoin", back_populates="coin", cascade="all, delete-orphan")

    def __repr__(self):
        return f"<Coin(id={self.id}, symbol={self.symbol}, name={self.name})>"

class CoinPrice(Base):
    """Model for storing current price data for cryptocurrencies."""
    __tablename__ = 'coin_prices'

    id = Column(Integer, primary_key=True)
    coin_id = Column(String, ForeignKey('coins.id', ondelete='CASCADE'), nullable=False)
    currency = Column(String, nullable=False)
    price = Column(Float)
    market_cap = Column(Float)
    volume_24h = Column(Float)
    price_change_24h = Column(Float)
    last_updated = Column(DateTime, default=datetime.utcnow)

    # Relationship
    coin = relationship("Coin", back_populates="prices")

    # Unique constraint for coin_id and currency combination
    __table_args__ = (UniqueConstraint('coin_id', 'currency', name='unique_coin_currency'),)

    def __repr__(self):
        return f"<CoinPrice(coin_id={self.coin_id}, currency={self.currency}, price={self.price})>"

class OHLC(Base):
    """Model for storing historical OHLC (Open, High, Low, Close) data."""
    __tablename__ = 'ohlc'

    id = Column(Integer, primary_key=True)
    coin_id = Column(String, ForeignKey('coins.id', ondelete='CASCADE'), nullable=False)
    timestamp = Column(DateTime, nullable=False)
    open = Column(Float, nullable=False)
    high = Column(Float, nullable=False)
    low = Column(Float, nullable=False)
    close = Column(Float, nullable=False)

    # Relationship
    coin = relationship("Coin", back_populates="ohlc_data")

    # Unique constraint for coin_id and timestamp combination
    __table_args__ = (UniqueConstraint('coin_id', 'timestamp', name='unique_coin_timestamp'),)

    def __repr__(self):
        return f"<OHLC(coin_id={self.coin_id}, timestamp={self.timestamp}, close={self.close})>"

class TrendingCoin(Base):
    """Model for storing trending cryptocurrency data."""
    __tablename__ = 'trending_coins'

    id = Column(Integer, primary_key=True)
    coin_id = Column(String, ForeignKey('coins.id', ondelete='CASCADE'), nullable=False)
    rank = Column(Integer, nullable=False)
    score = Column(Float)
    market_cap = Column(Float)
    thumb = Column(String)
    last_updated = Column(DateTime, default=datetime.utcnow)

    # Relationship
    coin = relationship("Coin", back_populates="trending_data")

    # Unique constraint for coin_id (one trending entry per coin)
    __table_args__ = (UniqueConstraint('coin_id', name='unique_trending_coin'),)

    def __repr__(self):
        return f"<TrendingCoin(coin_id={self.coin_id}, rank={self.rank}, score={self.score})>"

class UserType(enum.Enum):
    GUEST = "guest"
    PREMIUM = "premium"
    BANNED = "banned"    

class User(Base):
    __tablename__ = 'users'
    
    id = Column(Integer, primary_key=True)
    telegram_id = Column(String, unique=True, nullable=False)
    username = Column(String)
    user_type = Column(Enum(UserType), default=UserType.GUEST, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_active = Column(DateTime, default=datetime.utcnow)
    language = Column(String, default='en')
    
    # Relationships
    activities = relationship("UserActivity", back_populates="user", cascade="all, delete-orphan")
    searches = relationship("UserSearchHistory", back_populates="user", cascade="all, delete-orphan")

class UserSearchHistory(Base):
    __tablename__ = 'user_searches'
    
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey('users.id', ondelete='CASCADE'), nullable=False)
    coin_id = Column(String, ForeignKey('coins.id', ondelete='CASCADE'), nullable=False)
    search_date = Column(DateTime, default=datetime.utcnow)
    
    # Relationship
    user = relationship("User", back_populates="searches")

class UserActivity(Base):
    __tablename__ = 'user_activities'
    
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey('users.id', ondelete='CASCADE'), nullable=False)
    coin_id = Column(String, ForeignKey('coins.id', ondelete='CASCADE'), nullable=False)
    activity_type = Column(String, nullable=False)  # 'search', 'price_check', 'analysis', etc.
    timestamp = Column(DateTime, default=datetime.utcnow)
    details = Column(JSON)  # For storing any additional activity data
    
    # Relationship
    user = relationship("User", back_populates="activities")

class AdminTypes(enum.Enum):
    MASTER = "master"
    NORMAL = "normal"
    WATCHER = "watcher"

class Admin(Base):
    __tablename__ = 'admins'
    
    
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey('users.id', ondelete='CASCADE'), nullable=False)
    role = Column(Enum(AdminTypes), default=AdminTypes.NORMAL, nullable=False) 
    created_at = Column(DateTime, default=datetime.utcnow)
    created_by = Column(Integer, ForeignKey('admins.id'))
    is_active = Column(Boolean, default=True)
    
    # Relationships
    user = relationship("User")
    activities = relationship("AdminActivity", back_populates="admin", cascade="all, delete-orphan")

class AdminActivity(Base):
    __tablename__ = 'admin_activities'
    
    id = Column(Integer, primary_key=True)
    admin_id = Column(Integer, ForeignKey('admins.id', ondelete='CASCADE'), nullable=False)
    activity_type = Column(String, nullable=False)  # 'user_update', 'admin_add', etc.
    target_user_id = Column(Integer, ForeignKey('users.id'))  # Affected user if any
    timestamp = Column(DateTime, default=datetime.utcnow)
    details = Column(JSON)  # Store activity details
    
    # Relationships
    admin = relationship("Admin", back_populates="activities")
    target_user = relationship("User")
# Database initialization function
def init_db(database_url='sqlite:///crypto_analytics.db'):
    """Initialize the database and create all tables."""
    engine = create_engine(database_url)
    Base.metadata.create_all(engine)
    Session = sessionmaker(bind=engine)
    return Session()
</file>

<file path="services\database_manager.py">
from datetime import datetime, timedelta
from typing import List, Dict, Optional, Union, Tuple
from sqlalchemy import String, create_engine, and_, desc, func
from sqlalchemy.orm import sessionmaker, Session, joinedload
from sqlalchemy.exc import SQLAlchemyError, IntegrityError
from sqlalchemy.orm.exc import DetachedInstanceError
from contextlib import contextmanager
import logging
from typing import List, Dict, Optional, Union, Tuple
from .database import User, UserType, UserSearchHistory, UserActivity, Admin, AdminActivity, Base, Coin, CoinPrice, OHLC, TrendingCoin

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class DatabaseManager:
    def __init__(self, database_url: str = 'sqlite:///crypto_analytics.db'):
        """Initialize database connection and session maker."""
        self.engine = create_engine(database_url)
        Base.metadata.create_all(self.engine)
        self.SessionMaker = sessionmaker(bind=self.engine)

    @contextmanager
    def session_scope(self) -> Session:
        """Context manager for database sessions with automatic commit/rollback."""
        session = self.SessionMaker()
        try:
            yield session
            session.commit()
        except Exception as e:
            session.rollback()
            logger.error(f"Database error: {str(e)}")
            raise
        finally:
            session.close()

    def update_coin(self, coin_data: Dict) -> Optional[Coin]:
        """Add or update a coin in the database."""
        try:
            with self.session_scope() as session:
                coin = session.query(Coin).filter_by(id=coin_data['id']).first()
                if coin:
                    # Update existing coin
                    for key, value in coin_data.items():
                        setattr(coin, key, value)
                else:
                    # Create new coin
                    coin = Coin(**coin_data)
                    session.add(coin)
                session.flush()
                return coin
        except SQLAlchemyError as e:
            logger.error(f"Error updating coin {coin_data.get('id')}: {str(e)}")
            return None

    def bulk_update_coins(self, coins_data: List[Dict]) -> int:
        """Bulk update or insert coins."""
        success_count = 0
        try:
            with self.session_scope() as session:
                for coin_data in coins_data:
                    try:
                        coin = session.query(Coin).filter_by(id=coin_data['id']).first()
                        if coin:
                            for key, value in coin_data.items():
                                setattr(coin, key, value)
                        else:
                            coin = Coin(**coin_data)
                            session.add(coin)
                        success_count += 1
                    except SQLAlchemyError as e:
                        logger.error(f"Error processing coin {coin_data.get('id')}: {str(e)}")
                        continue
                session.flush()
        except SQLAlchemyError as e:
            logger.error(f"Bulk update error: {str(e)}")
        return success_count

    def update_coin_price(self, price_data: Dict) -> Optional[CoinPrice]:
        """Add or update a coin price entry."""
        try:
            with self.session_scope() as session:
                price = session.query(CoinPrice).filter_by(
                    coin_id=price_data['coin_id'],
                    currency=price_data['currency']
                ).first()
                
                if price:
                    for key, value in price_data.items():
                        setattr(price, key, value)
                else:
                    price = CoinPrice(**price_data)
                    session.add(price)
                session.flush()
                return price
        except SQLAlchemyError as e:
            logger.error(f"Error updating price for coin {price_data.get('coin_id')}: {str(e)}")
            return None

    def bulk_update_ohlc(self, ohlc_data_list: List[Dict]) -> int:
        """Bulk update or insert OHLC data."""
        success_count = 0
        try:
            with self.session_scope() as session:
                for ohlc_data in ohlc_data_list:
                    try:
                        ohlc = session.query(OHLC).filter_by(
                            coin_id=ohlc_data['coin_id'],
                            timestamp=ohlc_data['timestamp']
                        ).first()
                        
                        if ohlc:
                            for key, value in ohlc_data.items():
                                setattr(ohlc, key, value)
                        else:
                            ohlc = OHLC(**ohlc_data)
                            session.add(ohlc)
                        success_count += 1
                    except SQLAlchemyError as e:
                        logger.error(f"Error processing OHLC data: {str(e)}")
                        continue
                session.flush()
        except SQLAlchemyError as e:
            logger.error(f"Bulk OHLC update error: {str(e)}")
        return success_count

    def update_trending_coins(self, trending_data: List[Dict]) -> int:
        """Update trending coins list."""
        success_count = 0
        try:
            with self.session_scope() as session:
                # Clear existing trending data
                session.query(TrendingCoin).delete()
                
                # Add new trending data
                for trend_data in trending_data:
                    try:
                        trending = TrendingCoin(**trend_data)
                        session.add(trending)
                        success_count += 1
                    except SQLAlchemyError as e:
                        logger.error(f"Error processing trending coin: {str(e)}")
                        continue
                session.flush()
        except SQLAlchemyError as e:
            logger.error(f"Trending coins update error: {str(e)}")
        return success_count

    def sync_with_api(self, api_fetcher) -> Tuple[int, int, int, int]:
        """
        Sync database with latest data from API.
        Returns tuple of (coins_updated, prices_updated, ohlc_updated, trending_updated)
        """
        try:
            # Update coins
            coins_data = api_fetcher.fetch_coins()
            coins_updated = self.bulk_update_coins(coins_data)

            # Update prices
            prices_data = api_fetcher.fetch_prices()
            prices_updated = 0
            for price_data in prices_data:
                if self.update_coin_price(price_data):
                    prices_updated += 1

            # Update OHLC
            ohlc_data = api_fetcher.fetch_ohlc()
            ohlc_updated = self.bulk_update_ohlc(ohlc_data)

            # Update trending
            trending_data = api_fetcher.fetch_trending()
            trending_updated = self.update_trending_coins(trending_data)

            return coins_updated, prices_updated, ohlc_updated, trending_updated

        except Exception as e:
            logger.error(f"API sync error: {str(e)}")
            return 0, 0, 0, 0

    def _clone_object(self, obj):
        """Create a dictionary of object attributes, excluding SQLAlchemy internal attributes."""
        if not obj:
            return None
        return {
            key: getattr(obj, key)
            for key in obj.__table__.columns.keys()
        }

    def _clone_object_list(self, objects):
        """Create a list of dictionaries from objects, excluding SQLAlchemy internal attributes."""
        return [self._clone_object(obj) for obj in objects]

    def get_all_coins(self) -> List[Dict]:
        """Retrieve all coins from the database."""
        try:
            with self.session_scope() as session:
                coins = session.query(Coin).options(
                    joinedload(Coin.prices),
                    joinedload(Coin.ohlc_data),
                    joinedload(Coin.trending_data)
                ).all()
                # Convert to dictionaries before session closes
                return self._clone_object_list(coins)
        except SQLAlchemyError as e:
            logger.error(f"Error fetching coins: {str(e)}")
            return []

    def get_coin_by_id(self, coin_id: str) -> Optional[Dict]:
        """Retrieve a specific coin by ID."""
        try:
            with self.session_scope() as session:
                coin = session.query(Coin).options(
                    joinedload(Coin.prices),
                    joinedload(Coin.ohlc_data),
                    joinedload(Coin.trending_data)
                ).filter_by(id=coin_id).first()
                return self._clone_object(coin)
        except SQLAlchemyError as e:
            logger.error(f"Error fetching coin {coin_id}: {str(e)}")
            return None

    def get_coin_by_symbol(self, symbol: str) -> Optional[Dict]:
        """
        Retrieve a specific coin by its symbol (case-insensitive).
        
        Args:
            symbol (str): The symbol of the coin (e.g., 'btc' for Bitcoin)
            
        Returns:
            Optional[Dict]: Dictionary containing coin data if found, None otherwise
        """
        try:
            with self.session_scope() as session:
                coin = session.query(Coin).options(
                    joinedload(Coin.prices),
                    joinedload(Coin.ohlc_data),
                    joinedload(Coin.trending_data)
                ).filter(Coin.symbol.ilike(symbol)).first()
                
                return self._clone_object(coin)
        except SQLAlchemyError as e:
            logger.error(f"Error fetching coin with symbol {symbol}: {str(e)}")
            return None

    def get_coin_price(self, coin_id: str, currency: str = 'usd') -> Optional[Dict]:
        """Get current price data for a specific coin."""
        try:
            with self.session_scope() as session:
                price = session.query(CoinPrice).filter_by(
                    coin_id=coin_id,
                    currency=currency
                ).order_by(desc(CoinPrice.last_updated)).first()
                return self._clone_object(price)
        except SQLAlchemyError as e:
            logger.error(f"Error fetching price for coin {coin_id}: {str(e)}")
            return None

    def get_ohlc_data(
        self,
        coin_id: str,
        start_time: datetime,
        end_time: datetime
    ) -> List[Dict]:
        """Retrieve OHLC data for a coin within a time range."""
        try:
            with self.session_scope() as session:
                ohlc_data = session.query(OHLC).filter(
                    and_(
                        OHLC.coin_id == coin_id,
                        OHLC.timestamp >= start_time,
                        OHLC.timestamp <= end_time
                    )
                ).order_by(OHLC.timestamp).all()
                return self._clone_object_list(ohlc_data)
        except SQLAlchemyError as e:
            logger.error(f"Error fetching OHLC data for coin {coin_id}: {str(e)}")
            return []

    def get_trending_coins(self, limit: int = 10) -> List[Dict]:
        """Retrieve trending coins ordered by rank."""
        try:
            with self.session_scope() as session:
                trending = session.query(TrendingCoin).options(
                    joinedload(TrendingCoin.coin)
                ).order_by(
                    TrendingCoin.rank
                ).limit(limit).all()
                return self._clone_object_list(trending)
        except SQLAlchemyError as e:
            logger.error(f"Error fetching trending coins: {str(e)}")
            return []
        


        # Add these imports to existing ones


    def create_user(self, user_data: Dict) -> Optional[Dict]:
        """Create a new user in the database."""
        try:
            with self.session_scope() as session:
                user = User(**user_data)
                session.add(user)
                session.flush()
                return self._clone_object(user)
        except SQLAlchemyError as e:
            logger.error(f"Error creating user: {str(e)}")
            return None

    def get_user_by_telegram_id(self, telegram_id: str) -> Optional[Dict]:
        """Retrieve a user by their Telegram ID."""
        try:
            with self.session_scope() as session:
                user = session.query(User).filter_by(telegram_id=telegram_id).first()
                return self._clone_object(user)
        except SQLAlchemyError as e:
            logger.error(f"Error fetching user with telegram_id {telegram_id}: {str(e)}")
            return None

    def update_user_type(self, user_id: int, new_type: UserType, admin_id: int) -> Optional[Dict]:
        """Update a user's subscription type and log the change."""
        try:
            with self.session_scope() as session:
                user = session.query(User).filter_by(id=user_id).first()
                if not user:
                    return None

                old_type = user.user_type
                user.user_type = new_type
                user.last_active = datetime.utcnow()

                # Log admin activity
                admin_activity = AdminActivity(
                    admin_id=admin_id,
                    activity_type="user_type_update",
                    target_user_id=user_id,
                    details={
                        "old_type": old_type.value,
                        "new_type": new_type.value
                    }
                )
                session.add(admin_activity)
                session.flush()
                return self._clone_object(user)
        except SQLAlchemyError as e:
            logger.error(f"Error updating user type for user {user_id}: {str(e)}")
            return None

    def update_user_language(self, user_id: int, new_lang: UserType) -> bool:
        """Update user's language."""
        try:
            with self.session_scope() as session:
                user = session.query(User).filter_by(id=user_id).first()
                if not user:
                    return None

                user.user_type = new_lang

                session.flush()
                return True
        except SQLAlchemyError as e:
            logger.error(f"Error updating user language {user_id}: {str(e)}")
            return False

    def log_user_search(self, search_data: Dict) -> Optional[Dict]:
        """Log a user's search activity."""
        try:
            with self.session_scope() as session:
                search = UserSearchHistory(**search_data)
                session.add(search)
                session.flush()
                return self._clone_object(search)
        except SQLAlchemyError as e:
            logger.error(f"Error logging search for user {search_data.get('user_id')}: {str(e)}")
            return None

    def log_user_activity(self, activity_data: Dict) -> Optional[Dict]:
        """Log a user's activity."""
        try:
            with self.session_scope() as session:
                activity = UserActivity(**activity_data)
                session.add(activity)
                session.flush()
                return self._clone_object(activity)
        except SQLAlchemyError as e:
            logger.error(f"Error logging activity for user {activity_data.get('user_id')}: {str(e)}")
            return None

    def create_admin(self, admin_data: Dict) -> Optional[Dict]:
        """
        Create a new admin with specified role.
        
        admin_data should contain:
        - user_id: ID of the user to make admin
        - role: List of privilege strings
        - created_by: ID of admin creating this admin
        """
        try:
            with self.session_scope() as session:
                # Check if user is already an admin
                existing_admin = session.query(Admin).filter_by(
                    user_id=admin_data['user_id'],
                    is_active=True
                ).first()
                
                if existing_admin:
                    print("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n")
                    logger.error(f"User {admin_data['user_id']} is already an admin")
                    return None
                print("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n")
                admin = Admin(
                    user_id=admin_data['user_id'],
                    role=admin_data['role'],
                    created_by=admin_data.get('created_by')
                )
                session.add(admin)
                
                # Log admin creation
                # activity = AdminActivity(
                #     admin_id=admin_data['created_by'],
                #     activity_type="admin_created",
                #     target_user_id=admin_data['user_id'],
                #     details={"role": admin_data['role']}
                # )
                # session.add(activity)
                
                # session.flush()
                return self._clone_object(admin)
        except SQLAlchemyError as e:
            logger.error(f"Error creating admin: {str(e)}")
            return None

    def remove_admin(self, admin_id: int, removed_by: int) -> bool:
        """
        Remove an admin by setting is_active to False.
        Returns True if successful, False otherwise.
        """
        try:
            with self.session_scope() as session:
                admin = session.query(Admin).filter_by(id=admin_id, is_active=True).first()
                if not admin:
                    logger.error(f"Active admin with ID {admin_id} not found")
                    return False
                    
                admin.is_active = False
                
                # Log admin removal
                activity = AdminActivity(
                    admin_id=removed_by,
                    activity_type="admin_removed",
                    target_user_id=admin.user_id,
                    details={"removed_admin_id": admin_id}
                )
                session.add(activity)
                
                session.flush()
                return True
        except SQLAlchemyError as e:
            logger.error(f"Error removing admin {admin_id}: {str(e)}")
            return False
 
    def get_admin_by_user_id(self, user_id: int) -> Optional[Dict]:
        """Get admin info by user ID if they are an admin."""
        
        try:
            
            with self.session_scope() as session:
                admin = session.query(Admin).filter_by(
                    user_id=user_id,
                ).first()
                print('aaaaaaaaaaaaaaaaaaaaaaaaa')
                print(admin) 
                return self._clone_object(admin)
        except SQLAlchemyError as e:
            logger.error(f"Error fetching admin for user {user_id}: {str(e)}")
            return None

    def get_most_popular_searches(self, limit: int = 10) -> List[Dict]:
        """
        Retrieve the most popular searches across all users.
        
        Args:
            limit: Maximum number of results to return (default: 10)
            
        Returns:
            List of dictionaries containing search term and count
            Example: [{'search_term': 'BTC', 'count': 150}, ...]
        """
        try:
            with self.session_scope() as session:
                popular_searches = (
                    session.query(
                        UserSearchHistory.coin_id,
                        func.count(UserSearchHistory.coin_id).label('search_count')
                    )
                    .group_by(UserSearchHistory.coin_id)
                    .order_by(desc('search_count'))
                    .limit(limit)
                    .all()
                )
                
                # Convert to list of dictionaries
                return [
                    {
                        'search_term': search.coin_id,
                        'count': search.search_count
                    }
                    for search in popular_searches
                ]
        except SQLAlchemyError as e:
            logger.error(f"Error fetching popular searches: {str(e)}")
            return []
        
    def get_most_popular_analysis_types(self, limit: int = 10) -> List[Dict]:
        """
        Retrieve the most frequently performed analysis types across all users.
        Each unique combination of activity type and timestamp is counted as a separate analysis.
        
        Args:
            limit: Maximum number of results to return (default: 10)
            
        Returns:
            List of dictionaries containing analysis type and its frequency
            Example: [{'analysis_type': 'quick_analysis', 'count': 120}, ...]
        """
        try:
            with self.session_scope() as session:
                popular_analyses = (
                    session.query(
                        UserActivity.activity_type,
                        func.count(
                            func.distinct(
                                func.concat(
                                    UserActivity.activity_type,
                                    func.cast(UserActivity.timestamp, String)
                                )
                            )
                        ).label('activity_count')
                    )
                    .group_by(UserActivity.activity_type)
                    .order_by(desc('activity_count'))
                    .limit(limit)
                    .all()
                )
                
                # Convert to list of dictionaries with meaningful names
                return [
                    {
                        'analysis_type': activity.activity_type,
                        'frequency': activity.activity_count,
                        'percentage': round(
                            (activity.activity_count / sum(a.activity_count for a in popular_analyses)) * 100, 
                            2
                        ) if popular_analyses else 0
                    }
                    for activity in popular_analyses
                ]
        except SQLAlchemyError as e:
            logger.error(f"Error fetching popular analysis types: {str(e)}")
            return []

    def update_admin_role(self,admin_id,new_role,updated_by):
        try:
            with self.session_scope() as session:
                admin = session.query(Admin).filter_by(id=admin_id).first()
                if not admin:
                    return None

                old_role = admin.role
                admin.role = new_role
                
                # Log admin activity
                admin_activity = AdminActivity(
                    admin_id=updated_by,
                    activity_type="admin_role_change",
                    target_user_id=admin_id,
                    details={
                        "old_role": old_role.value,
                        "new_role": new_role.value
                    }
                )
                session.add(admin_activity)
                session.flush()
                return self._clone_object(admin)
        except SQLAlchemyError as e:
            logger.error(f"Error updating user role for admin {admin_id}: {str(e)}")
            return None

    def get_admin_activities(self, admin_id: Optional[int] = None, limit: int = 10) -> List[Dict]: 
        """Retrieve admin activities, optionally filtered by admin_id."""
        try:
            with self.session_scope() as session:
                query = session.query(AdminActivity)
                if admin_id is not None:
                    query = query.filter_by(admin_id=admin_id)
                activities = query.order_by(desc(AdminActivity.timestamp)).limit(limit).all()
                return self._clone_object_list(activities)
        except SQLAlchemyError as e:
            logger.error(f"Error fetching admin activities: {str(e)}")
            return []
</file>

<file path="services\models.py">
from sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, JSON, Index, Enum
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from datetime import datetime
import enum

Base = declarative_base()

class TimeInterval(enum.Enum):
    ONE_DAY = 1
    SEVEN_DAYS = 7
    THIRTY_DAYS = 30
    NINETY_DAYS = 90

class CryptoOHLCV(Base):
    __tablename__ = 'crypto_ohlcv'
    
    id = Column(Integer, primary_key=True)
    coin_id = Column(String, nullable=False)
    vs_currency = Column(String, nullable=False)
    interval = Column(Enum(TimeInterval), nullable=False)
    timestamp = Column(DateTime, nullable=False)
    open = Column(Float)
    high = Column(Float)
    low = Column(Float)
    close = Column(Float)
    volume = Column(Float)
    market_cap = Column(Float)
    last_updated = Column(DateTime, default=datetime.utcnow)

    # Create indexes for faster querying
    __table_args__ = (
        Index('idx_coin_currency_interval_timestamp', 
              'coin_id', 'vs_currency', 'interval', 'timestamp'),
        Index('idx_last_updated', 'last_updated'),
    )

class CoinMetadata(Base):
    __tablename__ = 'coin_metadata'
    
    id = Column(Integer, primary_key=True)
    coin_id = Column(String, unique=True, nullable=False)
    symbol = Column(String)
    name = Column(String)
    extra_data = Column(JSON)
    last_updated = Column(DateTime, default=datetime.utcnow)
</file>

<file path="utils\constants.py">
# src/utils/constants.py

TIMEFRAME_MAPPING = {
    '1d': '1',
    '7d': '7',
    '30d': '30',
    '90d': '90',
    '1y': '365',
    'max': 'max'
}

SUPPORTED_VS_CURRENCIES = ['usd', 'eur', 'gbp', 'btc', 'eth']
</file>

<file path="utils\formatters.py">
from typing import Dict, List
import json
import os

class TelegramFormatter:
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(TelegramFormatter, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        if not self._initialized:
            self.current_language = 'en'
            self.languages = {
                'en': self._load_language('en'),
                'ar': self._load_language('ar')
            }
            self._initialized = True
            
    def _get_education_content(self, language:str, category:str):
        """
        Get educational content from content.py
         Args:
            language: the language of the content
            category: the educational category

        Returns:
             dict: the data for this category
        """
        return educational_content.get_content(language,category)

    def _load_language(self, lang_code: str) -> Dict:
        
        try:

            file_path = os.path.join('src', 'languages', lang_code, 'messages.json')
            
            with open(file_path, 'r', encoding='utf-8') as file:
                file = json.load(file)
                return file
                
        except Exception:
            return {}

    def set_language(self, lang_code: str):

        if lang_code in self.languages:
            self.current_language = lang_code

    def _t(self, key: str) -> str:
        """Get translation for key"""
        return self.languages[self.current_language].get(key)

    def format_full_analysis(self, analysis: Dict, coin_id: str) -> str:
        """Format comprehensive analysis results"""
        
        try:
            if "error" in analysis:
                return f" {self._t('error_analysis')}: {analysis['error']}"

            sections = []

            # Header Section
            if 'basic_info' in analysis:
                header = self._format_header(analysis['basic_info'], coin_id)
                sections.append(header)

            # Trend Analysis
            if 'trend_indicators' in analysis:
                trend = self._format_trend_analysis(analysis['trend_indicators'])
                sections.append(trend)

            # Momentum Analysis
            if 'momentum_indicators' in analysis:
                momentum = self._format_momentum_analysis(analysis['momentum_indicators'])
                sections.append(momentum)

            # Volume Analysis
            if 'volume_indicators' in analysis:
                volume = self._format_volume_analysis(analysis['volume_indicators'])
                sections.append(volume)

            # Volatility Analysis
            if 'volatility_indicators' in analysis:
                volatility = self._format_volatility_analysis(analysis['volatility_indicators'])
                sections.append(volatility)

            # Pattern Recognition
            if analysis.get('patterns', {}).get('patterns'):
                patterns = self._format_patterns(analysis['patterns'])
                if patterns:  # Only add if there are patterns
                    sections.append(patterns)

            # Support/Resistance
            if 'support_resistance' in analysis:
                sr_levels = self._format_support_resistance(analysis['support_resistance'])
                sections.append(sr_levels)

            # Risk Assessment
            if 'summary' in analysis:
                risk = self._format_risk_assessment(analysis['summary'])
                sections.append(risk)

                # Final Summary
                summary = self._format_summary(analysis['summary'])
                sections.append(summary)

            return "\n\n".join(filter(None, sections))  # Filter out empty sections

        except Exception as e:
            print(f"Error in format_full_analysis: {str(e)}")
            import traceback
            traceback.print_exc()
            return f" Error formatting analysis: {str(e)}"

    def _format_header(self, info: Dict, coin_id: str) -> str:
        """Format basic information header"""
        price_change = info['price_change_24h']
        change_arrow = "" if price_change > 0 else ""
        
        return (
            f" {self._t('analysis_for')} {coin_id.upper()}\n"
            f"{'' * 32}\n"
            f" {self._t('current_price')}: ${info['current_price']:,.2f}\n"
            f" 24h {self._t('change')}: {change_arrow} {abs(price_change):.2f}%\n"
            f" 24h {self._t('high')}: ${info['high_24h']:,.2f}\n"
            f" 24h {self._t('low')}: ${info['low_24h']:,.2f}\n"
            f" 24h {self._t('volume')}: ${info['volume_24h']:,.0f}"
        )

    def _format_trend_analysis(self, trend: Dict) -> str:
        """Format trend indicators"""
        try:
            # Get moving averages data
            ma_data = trend.get('moving_averages', {})
            macd_data = trend.get('macd', {})
            adx_data = trend.get('adx', {})
            
            # Format moving averages section
            ma_section = [
                f" {self._t('trend_analysis')}",
                f"{'' * 32}",
                f" MA20: ${ma_data.get('ma20', 0):,.2f}",
                f" MA50: ${ma_data.get('ma50', 0):,.2f}",
                f" EMA20: ${ma_data.get('ema20', 0):,.2f}",
                f" {self._t('trend_signal')}: {self._format_signal(ma_data.get('signal', 'Neutral'))}"
            ]
            
            # Format MACD section
            macd_section = [
                "",
                " MACD:",
                f"  - Value: {macd_data.get('macd', 0):,.2f}",
                f"  - Signal: {macd_data.get('signal', 0):,.2f}",
                f"  - Histogram: {macd_data.get('histogram', 0):,.2f}",
                f"  - Cross: {macd_data.get('interpretation', {}).get('crossover', 'N/A')}"
            ]
            
            # Format ADX section
            adx_section = [
                "",
                " ADX:",
                f"  - Value: {adx_data.get('value', 0):,.2f}",
                f"  - Trend Strength: {adx_data.get('strength', {}).get('trend_strength', 'N/A')}"
            ]
            
            # Combine all sections
            return "\n".join(ma_section + macd_section + adx_section)
            
        except Exception as e:
            print(f"Debug: Error in trend formatting: {str(e)}")
            return f" {self._t('trend_analysis')}\n{'' * 32}\nError formatting trend data: {str(e)}"

    def _get_trend_emoji(self, trend: str) -> str:
        """Get emoji for trend signal"""
        emoji_map = {
            'Strong Bullish': '',
            'Bullish': '',
            'Neutral': '',
            'Bearish': '',
            'Strong Bearish': ''
        }
        return emoji_map.get(trend, '')

    def format_full_analysis(self, analysis: Dict, coin_id: str) -> str:
        """Format comprehensive analysis results"""
        print("\nDebug: Starting format_full_analysis")  # Debug print
        
        try:
            if "error" in analysis:
                return f" {self._t('error_analysis')}: {analysis['error']}"

            sections = []

            # Header Section
            print("Debug: Formatting header")  # Debug print
            if 'basic_info' in analysis:
                header = self._format_header(analysis['basic_info'], coin_id)
                sections.append(header)

            # Trend Analysis
            print("Debug: Formatting trend")  # Debug print
            if 'trend_indicators' in analysis:
                trend = self._format_trend_analysis(analysis['trend_indicators'])
                sections.append(trend)

            # Momentum Analysis
            print("Debug: Formatting momentum")  # Debug print
            if 'momentum_indicators' in analysis:
                momentum = self._format_momentum_analysis(analysis['momentum_indicators'])
                sections.append(momentum)

            # Volume Analysis
            print("Debug: Formatting volume")  # Debug print
            if 'volume_indicators' in analysis:
                volume = self._format_volume_analysis(analysis['volume_indicators'])
                sections.append(volume)

            # Volatility Analysis
            print("Debug: Formatting volatility")  # Debug print
            if 'volatility_indicators' in analysis:
                volatility = self._format_volatility_analysis(analysis['volatility_indicators'])
                sections.append(volatility)

            print("Debug: Joining sections")  # Debug print
            return "\n\n".join(sections)

        except Exception as e:
            print(f"Debug: Error in format_full_analysis: {str(e)}")  # Debug print
            import traceback
            print("Debug: Full traceback:", traceback.format_exc())  # Debug print
            return f"Error formatting analysis: {str(e)}"

    

    
    def _format_risk_assessment(self, summary: Dict) -> str:
        """Format risk assessment"""
        risk_level = summary.get('risk_level', 'Medium')
        risk_emoji = {
            'Low': '',
            'Medium': '',
            'High': '',
            'Very High': ''
        }.get(risk_level, '')
        
        return (
            f" {self._t('risk_assessment')}\n"
            f"{'' * 32}\n"
            f" {self._t('risk_level')}: {risk_emoji} {risk_level}\n"
            f" {self._t('volatility_level')}: {summary.get('volatility_assessment', 'N/A')}\n"
            f" {self._t('market_strength')}: {summary.get('market_strength', 'N/A')}"
        )

    def _format_summary(self, summary: Dict) -> str:
        """Format final summary"""
        signals = summary.get('signals', [])
        confidence = summary.get('confidence', 0)
        
        summary_text = [
            f" {self._t('summary')}",
            f"{'' * 32}",
            f" {self._t('overall_sentiment')}: {self._get_sentiment_emoji(summary['overall_sentiment'])} {summary['overall_sentiment']}",
            f" {self._t('confidence')}: {confidence}%",
            "",
            f" {self._t('key_signals')}:"
        ]
        
        for signal in signals:
            emoji = self._get_sentiment_emoji(signal[0])
            summary_text.append(f" {emoji} {signal[1]}")
        
        return "\n".join(summary_text)

    # Helper formatting methods
    def _format_rsi(self, rsi_data: Dict) -> str:
        value = rsi_data['value']
        signal = rsi_data['signal']
        return f"{value:.1f} {self._get_rsi_emoji(value)} ({signal})"

    def _format_macd_data(self, macd_data: Dict) -> str:
        return f"{macd_data['macd']:.2f} [{macd_data['interpretation']}]"

    def _get_trend_emoji(self, trend: str) -> str:
        return {
            'Strong Bullish': '',
            'Bullish': '',
            'Neutral': '',
            'Bearish': '',
            'Strong Bearish': ''
        }.get(trend, '')

    def _get_sentiment_emoji(self, sentiment: str) -> str :
        """Get emoji for sentiment"""
        return {
            'Bullish': '',
            'Bearish': '',
            'Neutral': '',
            'Strong Bullish': '',
            'Strong Bearish': ''
        }.get(sentiment, '')

    def _get_rsi_emoji(self, value: float) -> str:
        if value >= 70: return ''
        if value <= 30: return ''
        return ''

    # Error handling
    def format_error_message(self, error: str) -> str:
        """Format error messages"""
        return f" {self._t('error')}: {error}"

    def format_loading_message(self) -> str:
        """Format loading message"""
        return f" {self._t('analyzing')}..."
    
    def _format_stochastic(self, stoch_data: Dict) -> str:
        """Format stochastic oscillator data"""
        k = stoch_data['k']
        d = stoch_data['d']
        signal = stoch_data['signal']
        
        if k > 80 or k < 20:
            emoji = "" if k > 80 else ""
        else:
            emoji = ""
            
        return f"K:{k:.1f} D:{d:.1f} {emoji} [{signal}]"

    def _format_cci(self, cci_data: Dict) -> str:
        """Format CCI data"""
        value = cci_data['value']
        signal = cci_data['signal']
        
        if value > 100:
            emoji = ""
        elif value < -100:
            emoji = ""
        else:
            emoji = ""
            
        return f"{value:.1f} {emoji} [{signal}]"

    def _format_mfi(self, mfi_data: Dict) -> str:
        """Format Money Flow Index data"""
        value = mfi_data['value']
        signal = mfi_data['signal']
        
        if value > 80:
            emoji = ""
        elif value < 20:
            emoji = ""
        else:
            emoji = ""
            
        return f"{value:.1f} {emoji} [{signal}]"

    def _format_roc(self, roc_data: Dict) -> str:
        """Format Rate of Change data"""
        value = roc_data['value']
        signal = roc_data['signal']
        
        if value > 0:
            emoji = ""
        elif value < 0:
            emoji = ""
        else:
            emoji = ""
            
        return f"{value:.1f}% {emoji} [{signal}]"

    def _format_williams_r(self, williams_data: Dict) -> str:
        """Format Williams %R data"""
        value = williams_data['value']
        signal = williams_data['signal']
        
        if value > -20:
            emoji = ""
        elif value < -80:
            emoji = ""
        else:
            emoji = ""
            
        return f"{value:.1f} {emoji} [{signal}]"

    def _format_obv(self, obv_data: Dict) -> str:
        """Format On Balance Volume data"""
        value = obv_data['value']
        change = obv_data['change']
        signal = obv_data['signal']
        
        if change > 0:
            emoji = ""
        elif change < 0:
            emoji = ""
        else:
            emoji = ""
            
        return f"{self._format_large_number(value)} {emoji} [{signal}]"

    def _format_vwap(self, vwap_data: Dict) -> str:
        """Format VWAP data"""
        value = vwap_data['value']
        signal = vwap_data['signal']
        
        return f"${value:,.2f} [{signal}]"

    def _format_cmf(self, cmf_data: Dict) -> str:
        """Format Chaikin Money Flow data"""
        value = cmf_data['value']
        signal = cmf_data['signal']
        
        if value > 0.1:
            emoji = ""
        elif value < -0.1:
            emoji = ""
        else:
            emoji = ""
            
        return f"{value:.3f} {emoji} [{signal}]"

    def _format_ad(self, ad_data: Dict) -> str:
        """Format Accumulation/Distribution data"""
        signal = ad_data['signal']
        
        if signal == "Accumulation":
            emoji = ""
        elif signal == "Distribution":
            emoji = ""
        else:
            emoji = ""
            
        return f"{emoji} [{signal}]"

    def _format_atr(self, atr_data: Dict) -> str:
        """Format Average True Range data"""
        value = atr_data['value']
        percentage = atr_data['percentage']
        interpretation = atr_data['interpretation']
        
        return f"${value:.2f} ({percentage:.1f}%) [{interpretation}]"

    def _format_historical_volatility(self, vol_data: Dict) -> str:
        """Format Historical Volatility data"""
        value = vol_data['value']
        interpretation = vol_data['interpretation']
        
        if value > 50:
            emoji = ""
        elif value < 20:
            emoji = ""
        else:
            emoji = ""
            
        return f"{value:.1f}% {emoji} [{interpretation}]"

    def _format_large_number(self, number: float) -> str:
        """Format large numbers with K, M, B suffixes"""
        if abs(number) >= 1e9:
            return f"{number/1e9:.2f}B"
        elif abs(number) >= 1e6:
            return f"{number/1e6:.2f}M"
        elif abs(number) >= 1e3:
            return f"{number/1e3:.2f}K"
        else:
            return f"{number:.2f}"

    def _format_support_resistance(self, levels: Dict) -> str:
        """Format support and resistance levels"""
        support_levels = levels.get('support_levels', [])
        resistance_levels = levels.get('resistance_levels', [])
        
        formatted_lines = [
            f" {self._t('support_resistance')}",
            f"{'' * 32}"
        ]
        
        if resistance_levels:
            formatted_lines.append(f" {self._t('resistance_at')}: ${resistance_levels[0]:,.2f}")
            if len(resistance_levels) > 1:
                formatted_lines.append(f" {self._t('next_resistance')}: ${resistance_levels[1]:,.2f}")
                
        if support_levels:
            formatted_lines.append(f" {self._t('support_at')}: ${support_levels[-1]:,.2f}")
            if len(support_levels) > 1:
                formatted_lines.append(f" {self._t('next_support')}: ${support_levels[-2]:,.2f}")
                
        return "\n".join(formatted_lines)

    def _format_patterns(self, patterns: Dict) -> str:
        """Format pattern recognition results"""
        pattern_list = patterns.get('patterns', {})
        if not pattern_list:
            return ""
            
        formatted_lines = [
            f" {self._t('patterns_detected')}",
            f"{'' * 32}"
        ]
        
        for pattern_name in pattern_list:
            formatted_name = pattern_name.replace('_', ' ').title()
            formatted_lines.append(f" {formatted_name}")
            
        return "\n".join(formatted_lines)
    
    def _format_volume_trend(self, volume_data: Dict) -> str:
        """Format volume trend data"""
        current = volume_data['current_volume']
        sma = volume_data['sma']
        ratio = volume_data['ratio']
        
        if ratio > 1.5:
            trend = f" {self._t('very_high')}"
        elif ratio > 1.2:
            trend = f" {self._t('high')}"
        elif ratio < 0.8:
            trend = f" {self._t('low')}"
        elif ratio < 0.5:
            trend = f" {self._t('very_low')}"
        else:
            trend = f" {self._t('normal')}"
            
        return f"{self._format_large_number(current)} / {self._format_large_number(sma)} [{trend}]"

    def _format_price_action(self, price_data: Dict) -> str:
        """Format price action data"""
        trend = price_data['trend']
        strength = price_data['strength']
        
        emoji = {
            'Strong Uptrend': '',
            'Uptrend': '',
            'Sideways': '',
            'Downtrend': '',
            'Strong Downtrend': ''
        }.get(trend, '')
        
        return f"{emoji} {trend} ({strength}%)"

    def _format_fibonacci_levels(self, fib_data: Dict) -> str:
        """Format Fibonacci retracement levels"""
        levels = [
            f" 0.236: ${fib_data['0.236']:,.2f}",
            f" 0.382: ${fib_data['0.382']:,.2f}",
            f" 0.500: ${fib_data['0.500']:,.2f}",
            f" 0.618: ${fib_data['0.618']:,.2f}",
            f" 0.786: ${fib_data['0.786']:,.2f}"
        ]
        return "\n".join(levels)

    def _format_pivot_points(self, pivot_data: Dict) -> str:
        """Format pivot points"""
        return (
            f"P: ${pivot_data['P']:,.2f}\n"
            f"R1: ${pivot_data['R1']:,.2f}\n"
            f"R2: ${pivot_data['R2']:,.2f}\n"
            f"S1: ${pivot_data['S1']:,.2f}\n"
            f"S2: ${pivot_data['S2']:,.2f}"
        )

    def _format_moving_averages(self, ma_data: Dict) -> str:
        """Format moving averages data"""
        crosses = []
        for ma in ['MA20', 'MA50', 'MA200']:
            if ma_data[ma.lower()]['cross'] == 'above':
                crosses.append(f" Price above {ma}")
            elif ma_data[ma.lower()]['cross'] == 'below':
                crosses.append(f" Price below {ma}")
                
        return "\n".join(crosses) if crosses else " No significant crosses"

    def _format_volatility_bands(self, bands_data: Dict) -> str:
        """Format volatility bands data"""
        position = bands_data['position']
        
        if position == 'above':
            return " Price above bands (High volatility)"
        elif position == 'below':
            return " Price below bands (Low volatility)"
        else:
            return " Price within bands (Normal volatility)"

    def _format_trend_strength(self, strength_data: Dict) -> str:
        """Format trend strength indicator"""
        strength = strength_data['value']
        direction = strength_data['direction']
        
        if strength > 40:
            emoji = ""
        elif strength > 20:
            emoji = ""
        else:
            emoji = ""
            
        return f"{emoji} {direction} ({strength}%)"

    def _format_divergence(self, divergence_data: Dict) -> str:
        """Format divergence signals"""
        if not divergence_data['present']:
            return "No divergence detected"
            
        type_emoji = {
            'bullish': '',
            'bearish': '',
            'hidden_bullish': '',
            'hidden_bearish': ''
        }
        
        return f"{type_emoji[divergence_data['type']]} {divergence_data['type'].replace('_', ' ').title()} divergence"

    def _format_pattern_confidence(self, pattern_data: Dict) -> str:
        """Format pattern confidence levels"""
        confidence = pattern_data['confidence']
        
        if confidence >= 80:
            emoji = ""
        elif confidence >= 60:
            emoji = ""
        else:
            emoji = ""
            
        return f"{emoji} {confidence}% confidence"

    def _format_market_condition(self, condition_data: Dict) -> str:
        """Format overall market condition"""
        condition = condition_data['condition']
        strength = condition_data['strength']
        
        emojis = {
            'Strong Bull': '',
            'Bull': '',
            'Neutral': '',
            'Bear': '',
            'Strong Bear': ''
        }
        
        return f"{emojis.get(condition, '')} {condition} ({strength}%)"

    def _format_risk_rating(self, risk_data: Dict) -> str:
        """Format risk rating"""
        risk_level = risk_data['level']
        score = risk_data['score']
        
        emojis = {
            'Very High': '',
            'High': '',
            'Medium': '',
            'Low': '',
            'Very Low': ''
        }
        
        return f"{emojis.get(risk_level, '')} {risk_level} Risk ({score}%)"

    def _format_signal(self, signal: str) -> str:
        """Format signal with appropriate emoji"""
        emoji_map = {
            'Strong Bullish': '',
            'Bullish': '',
            'Neutral': '',
            'Bearish': '',
            'Strong Bearish': ''
        }
        emoji = emoji_map.get(signal, '')
        return f"{emoji} {signal}"

    def _format_consolidated_rating(self, rating_data: Dict) -> str:
        """Format consolidated analysis rating"""
        rating = rating_data['rating']
        score = rating_data['score']
        
        emojis = {
            'Strong Buy': '',
            'Buy': '',
            'Neutral': '',
            'Sell': '',
            'Strong Sell': ''
        }
        
        return f"{emojis.get(rating, '')} {rating} ({score}%)"
    
    
    def _format_momentum_analysis(self, momentum: Dict) -> str:
        """Format momentum indicators"""
        try:
            # Start momentum section
            sections = [
                f" {self._t('momentum_analysis')}",
                f"{'' * 32}"
            ]
            
            # RSI
            if 'rsi' in momentum:
                rsi_data = momentum['rsi']
                rsi_value = rsi_data.get('value', 0)
                rsi_signal = self._get_rsi_signal(rsi_value)
                sections.append(f" RSI: {rsi_value:.2f} {rsi_signal}")
            
            # Stochastic
            if 'stochastic' in momentum:
                stoch = momentum['stochastic']
                sections.append(f" Stochastic: K({stoch.get('k', 0):.1f}) D({stoch.get('d', 0):.1f})")
            
            # Williams %R
            if 'williams_r' in momentum:
                williams = momentum['williams_r']
                sections.append(f" Williams %R: {williams.get('value', 0):.1f}")
            
            # MFI
            if 'mfi' in momentum:
                mfi = momentum['mfi']
                sections.append(f" Money Flow Index: {mfi.get('value', 0):.1f}")
            
            # CCI
            if 'cci' in momentum:
                cci = momentum['cci']
                sections.append(f" CCI: {cci.get('value', 0):.1f}")
            
            return "\n".join(sections)
        except Exception as e:
            return f" {self._t('momentum_analysis')}\n{'' * 32}\nError: {str(e)}"

    def _format_volume_analysis(self, volume: Dict) -> str:
        """Format volume indicators"""
        try:
            sections = [
                f" {self._t('volume_analysis')}",
                f"{'' * 32}"
            ]
            
            # Volume SMA
            if 'volume_sma' in volume:
                vol_sma = volume['volume_sma']
                current_vol = self._format_large_number(vol_sma.get('current_volume', 0))
                avg_vol = self._format_large_number(vol_sma.get('sma', 0))
                sections.append(f" Current Volume: {current_vol}")
                sections.append(f" Average Volume: {avg_vol}")
            
            # OBV
            if 'obv' in volume:
                obv_data = volume['obv']
                sections.append(f" OBV: {self._format_large_number(obv_data.get('value', 0))}")
            
            # VWAP
            if 'vwap' in volume:
                vwap_data = volume['vwap']
                sections.append(f" VWAP: ${vwap_data.get('value', 0):,.2f}")
            
            # Chaikin Money Flow
            if 'chaikin_money_flow' in volume:
                cmf = volume['chaikin_money_flow']
                sections.append(f" CMF: {cmf.get('value', 0):.3f}")
            
            return "\n".join(sections)
        except Exception as e:
            return f" {self._t('volume_analysis')}\n{'' * 32}\nError: {str(e)}"

    def _format_volatility_analysis(self, volatility: Dict) -> str:
        """Format volatility indicators"""
        try:
            sections = [
                f" {self._t('volatility_analysis')}",
                f"{'' * 32}"
            ]
            
            # Bollinger Bands
            if 'bollinger_bands' in volatility:
                bb = volatility['bollinger_bands']
                sections.extend([
                    f" Bollinger Bands:",
                    f"  - Upper: ${bb.get('upper', 0):,.2f}",
                    f"  - Middle: ${bb.get('middle', 0):,.2f}",
                    f"  - Lower: ${bb.get('lower', 0):,.2f}",
                    f"  - Width: {bb.get('bandwidth', 0):.2f}%"
                ])
            
            # ATR
            if 'atr' in volatility:
                atr = volatility['atr']
                sections.append(f" ATR: ${atr.get('value', 0):,.2f} ({atr.get('percentage', 0):.1f}%)")
            
            # Historical Volatility
            if 'historical_volatility' in volatility:
                hist_vol = volatility['historical_volatility']
                sections.append(f" Historical Volatility: {hist_vol.get('value', 0):.1f}%")
            
            return "\n".join(sections)
        except Exception as e:
            return f" {self._t('volatility_analysis')}\n{'' * 32}\nError: {str(e)}"

    def _get_rsi_signal(self, value: float) -> str:
        """Get RSI signal with emoji"""
        if value >= 70:
            return " Overbought"
        elif value <= 30:
            return " Oversold"
        else:
            return " Neutral"
</file>

<file path="utils\news_formatters.py">
from typing import Dict
import pandas as pd

class NewsFormatter:
    def format_news(self, df: pd.DataFrame, coin_symbol: str) -> str:
        """Format news data into a readable message with emojis"""
        try:
            # Get statistics
            stats = self._get_news_stats(df)
            
            # Get recent articles (top 5)
            recent_articles = df.nlargest(5, 'published_on')
            
            # Build message
            message_parts = [
                f" News Summary for {coin_symbol}",
                "" * 32,
                "",
                " Statistics:",
                f" Total Articles: {stats['total_articles']}",
                f" Sources: {stats['unique_sources']}",
                f" Most Active Source: {stats['most_common_source']}",
                f" Overall Sentiment: {self._get_sentiment_emoji(stats['sentiment_distribution'])}",
                "",
                " Latest Articles:",
            ]
            
            # Add recent articles
            for _, article in recent_articles.iterrows():
                pub_date = article['published_on'].strftime('%Y-%m-%d %H:%M')
                message_parts.extend([
                    f"  {article['title']}",
                    f"   {article['url']}",
                    f"   {pub_date}",
                    f"  {self._get_sentiment_emoji(article['sentiment'])} {article['sentiment']}",
                    ""
                ])
            
            # Add trending categories if available
            if stats['top_categories']:
                message_parts.extend([
                    " Top Categories:",
                    *[f" {cat}: {count}" for cat, count in stats['top_categories'].items()],
                    ""
                ])
            
            return "\n".join(message_parts)
            
        except Exception as e:
            return f"Error formatting news: {str(e)}"
    
    def _get_news_stats(self, df: pd.DataFrame) -> Dict:
        """Get basic statistics about the news articles"""
        stats = {
            'total_articles': len(df),
            'unique_sources': df['source_name'].nunique(),
            'most_common_source': df['source_name'].mode().iloc[0] if not df['source_name'].empty else "N/A",
            'sentiment_distribution': df['sentiment'].mode().iloc[0] if not df['sentiment'].empty else "NEUTRAL",
            'top_categories': pd.Series([
                cat for cats in df['categories'].dropna() 
                for cat in cats.split('|')
            ]).value_counts().head(3).to_dict()
        }
        return stats
    
    def _get_sentiment_emoji(self, sentiment: str) -> str:
        """Convert sentiment to emoji"""
        sentiment_map = {
            'POSITIVE': ' POSITIVE',
            'VERY POSITIVE': ' VERY POSITIVE',
            'NEUTRAL': ' NEUTRAL',
            'NEGATIVE': ' NEGATIVE',
            'VERY NEGATIVE': ' VERY NEGATIVE'
        }
        return sentiment_map.get(sentiment.upper(), '')
    
    def format_loading_message(self) -> str:
        """Format loading message"""
        return " Fetching latest crypto news..."
    
    def format_error_message(self, error: str) -> str:
        """Format error message"""
        return f" Error fetching news: {error}"
</file>

</repository_files>
